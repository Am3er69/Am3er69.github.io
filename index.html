<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Forex Signal Analyzer ‚Äî Chart Patterns + Market Structure</title>
  <style>
    body {
      font-family: "Poppins", Arial, sans-serif;
      background: #0a1224;
      color: #fff;
      margin: 0;
      padding: 0;
      text-align: center;
    }
    h1 {
      margin-top: 25px;
      font-size: 1.9em;
      color: #3cbefc;
    }
    button {
      background: #3cbefc;
      border: none;
      color: #fff;
      font-weight: bold;
      padding: 12px 24px;
      border-radius: 10px;
      cursor: pointer;
      margin-top: 15px;
      transition: 0.3s;
    }
    button:hover {
      background: #2ca2d8;
    }
    .signal-card {
      background: #121c36;
      margin: 15px auto;
      padding: 15px;
      width: 85%;
      max-width: 580px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      text-align: left;
    }
    .no-signal {
      color: #aaa;
      font-style: italic;
    }
    .volatility {
      font-weight: bold;
      padding: 6px 10px;
      border-radius: 8px;
      display: inline-block;
      margin-top: 6px;
    }
    .low { background: #27ae60; }
    .medium { background: #f1c40f; color: #000; }
    .high { background: #e74c3c; }
    .pattern, .structure {
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.9em;
      margin-top: 4px;
      display: inline-block;
    }
    .pattern { background: #9b59b6; color: white; }
    .structure { background: #3498db; color: white; }
    .chart-pattern { background: #e67e22; color: white; }
    .confidence-container {
      background: #2b3558;
      border-radius: 8px;
      margin-top: 8px;
      overflow: hidden;
      height: 10px;
      width: 100%;
    }
    .confidence-bar {
      height: 10px;
      transition: width 0.6s ease;
      background: linear-gradient(90deg, #ff3c3c, #f1c40f, #27ae60);
    }
    footer {
      margin: 20px 0;
      color: #ccc;
      font-size: 0.9em;
    }
    #loading {
      color: #3cbefc;
      margin-top: 20px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>AI Forex Signal Analyzer ‚Äî Chart Patterns + Market Structure üìäüïØÔ∏è</h1>
  <button onclick="generateSignals()">üîÑ Refresh Signals</button>
  <div id="loading" style="display:none;">Analyzing chart patterns...</div>
  <div id="signals"></div>
  <footer id="lastUpdated"></footer>

  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>

  <script>
    const pairs = ["EUR/USD", "GBP/USD", "USD/JPY", "AUD/USD", "XAU/USD"];
    const signalsDiv = document.getElementById("signals");
    const lastUpdated = document.getElementById("lastUpdated");
    const loadingDiv = document.getElementById("loading");
    const API_KEY = "318e2543fba14c57836adc5ce228ee7e"; // Your Twelve Data API key

    const symbolMap = {
      "EUR/USD": "EUR/USD",
      "GBP/USD": "GBP/USD",
      "USD/JPY": "USD/JPY",
      "AUD/USD": "AUD/USD",
      "XAU/USD": "XAU/USD"
    };

    // Account & risk settings
    const ACCOUNT_BALANCE = 1000;
    const RISK_PERCENT = 0.01;
    const RISK_AMOUNT = ACCOUNT_BALANCE * RISK_PERCENT;

    function getPipSize(pair) {
      return pair === "XAU/USD" || pair === "USD/JPY" ? 0.01 : 0.0001;
    }

    function formatPrice(price, pair) {
      const decimals = (pair === "USD/JPY" || pair === "XAU/USD") ? 2 : 5;
      return parseFloat(price).toFixed(decimals);
    }

    // üî• CANDLESTICK PATTERNS
    function detectCandlestickSignal(candles) {
      if (candles.length < 2) return null;
      const curr = candles[0], prev = candles[1];
      const currBody = Math.abs(curr.close - curr.open);
      const currWickTop = curr.high - Math.max(curr.open, curr.close);
      const currWickBottom = Math.min(curr.open, curr.close) - curr.low;

      if (curr.close > curr.open && prev.close < prev.open && curr.open < prev.close && curr.close > prev.open)
        return "bullish_engulfing";
      if (curr.close < curr.open && prev.close > prev.open && curr.open > prev.close && curr.close < prev.open)
        return "bearish_engulfing";
      if (currWickBottom > 2 * currBody && currWickTop < currBody)
        return "bullish_pin";
      if (currWickTop > 2 * currBody && currWickBottom < currBody)
        return "bearish_pin";
      return null;
    }

    // üî• MARKET STRUCTURE
    function detectSwings(candles, lookback = 5) {
      let swings = { highs: [], lows: [] };
      for (let i = lookback; i < candles.length - lookback; i++) {
        const isHigh = candles.slice(i - lookback, i + lookback + 1)
          .every((c, idx) => c.high <= candles[i].high || idx === lookback);
        if (isHigh) swings.highs.push(candles[i].high);
        const isLow = candles.slice(i - lookback, i + lookback + 1)
          .every((c, idx) => c.low >= candles[i].low || idx === lookback);
        if (isLow) swings.lows.push(candles[i].low);
      }
      return swings;
    }

    function detectFVG(candles) {
      const fvgZones = [];
      for (let i = 2; i < candles.length; i++) {
        const prev = candles[i];
        const mid = candles[i - 1];
        const next = candles[i - 2];
        if (mid.low > prev.high && mid.low > next.high) {
          fvgZones.push({ type: "bullish", low: mid.low, high: mid.high });
        } else if (mid.high < prev.low && mid.high < next.low) {
          fvgZones.push({ type: "bearish", low: mid.low, high: mid.high });
        }
      }
      return fvgZones;
    }

    function detectSupplyDemand(candles, atr) {
      const zones = { demand: [], supply: [] };
      for (let i = 3; i < candles.length - 3; i++) {
        const base = candles.slice(i, i + 3);
        const rangeHigh = Math.max(...base.map(c => c.high));
        const rangeLow = Math.min(...base.map(c => c.low));
        const range = rangeHigh - rangeLow;
        if (range < atr * 0.8) {
          const breakoutUp = candles[i - 1] && candles[i - 1].close > rangeHigh;
          const breakoutDown = candles[i - 1] && candles[i - 1].close < rangeLow;
          if (breakoutUp) zones.demand.push({ low: rangeLow, high: rangeHigh });
          if (breakoutDown) zones.supply.push({ low: rangeLow, high: rangeHigh });
        }
      }
      return zones;
    }

    // üî• CHART PATTERN DETECTION (Core Upgrade)
    function detectChartPatterns(candles, atr) {
      const patterns = [];
      const n = candles.length;

      // Double Top / Bottom
      if (n >= 20) {
        const highs = candles.slice(0, 20).map(c => c.high);
        const lows = candles.slice(0, 20).map(c => c.low);
        const max1 = Math.max(...highs.slice(0, 10));
        const max2 = Math.max(...highs.slice(10, 20));
        const min1 = Math.min(...lows.slice(0, 10));
        const min2 = Math.min(...lows.slice(10, 20));
        if (Math.abs(max1 - max2) < atr * 1.5 && Math.abs(min1 - min2) < atr * 1.5) {
          if (candles[0].close < Math.min(max1, max2) - atr * 0.8) {
            patterns.push("double_top");
          } else if (candles[0].close > Math.max(min1, min2) + atr * 0.8) {
            patterns.push("double_bottom");
          }
        }
      }

      // Triangles (last 15 candles)
      if (n >= 15) {
        const recent = candles.slice(0, 15);
        const highs = recent.map(c => c.high);
        const lows = recent.map(c => c.low);
        const highestHigh = Math.max(...highs);
        const lowestLow = Math.min(...lows);
        const recentHigh = highs[0];
        const recentLow = lows[0];

        // Ascending Triangle: flat highs, rising lows
        if (Math.abs(highestHigh - recentHigh) < atr * 0.3 && lows[0] > lows[5] + atr * 0.5) {
          patterns.push("ascending_triangle");
        }
        // Descending Triangle: flat lows, falling highs
        else if (Math.abs(lowestLow - recentLow) < atr * 0.3 && highs[0] < highs[5] - atr * 0.5) {
          patterns.push("descending_triangle");
        }
        // Symmetrical Triangle: converging
        else if (Math.abs(highestHigh - recentHigh) < atr * 0.5 && Math.abs(lowestLow - recentLow) < atr * 0.5) {
          patterns.push("symmetrical_triangle");
        }
      }

      // Head & Shoulders (simplified)
      if (n >= 30) {
        const peaks = [];
        for (let i = 5; i < 25; i++) {
          if (candles[i].high > candles[i-1].high && candles[i].high > candles[i+1].high) {
            peaks.push({ index: i, price: candles[i].high });
          }
        }
        if (peaks.length >= 3) {
          const [left, head, right] = peaks.slice(0, 3);
          if (head.price > left.price && head.price > right.price && Math.abs(left.price - right.price) < atr * 1.5) {
            if (candles[0].close < Math.min(left.price, right.price) - atr * 0.5) {
              patterns.push("head_and_shoulders");
            }
          }
        }
      }

      // Flag (strong move + consolidation)
      if (n >= 10) {
        const move = candles[5].close - candles[9].close;
        const consolidation = Math.max(...candles.slice(0, 5).map(c => c.high)) - Math.min(...candles.slice(0, 5).map(c => c.low));
        if (Math.abs(move) > atr * 2 && consolidation < atr * 0.8) {
          if (move > 0) patterns.push("bullish_flag");
          else patterns.push("bearish_flag");
        }
      }

      // Cup & Handle (simplified)
      if (n >= 25) {
        const lows = candles.slice(0, 25).map(c => c.low);
        const minIndex = lows.indexOf(Math.min(...lows));
        if (minIndex > 8 && minIndex < 17) {
          const leftAvg = lows.slice(0, minIndex).reduce((a,b) => a + b, 0) / minIndex;
          const rightAvg = lows.slice(minIndex + 1, 25).reduce((a,b) => a + b, 0) / (24 - minIndex);
          if (Math.abs(leftAvg - rightAvg) < atr * 0.8 && candles[0].close > leftAvg + atr * 0.5) {
            patterns.push("cup_and_handle");
          }
        }
      }

      return patterns;
    }

    // Fetch data
    async function fetchCandlesAndIndicators(pair) {
      const symbol = symbolMap[pair];
      if (!symbol) return null;
      const url = `https://api.twelvedata.com/time_series?symbol=${encodeURIComponent(symbol)}&interval=15min&outputsize=50&apikey=${API_KEY}`;
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        if (!data.values || data.values.length < 30) return null;

        const closes = data.values.map(v => parseFloat(v.close));
        const highs = data.values.map(v => parseFloat(v.high));
        const lows = data.values.map(v => parseFloat(v.low));
        const ema200 = calculateEMA(closes, 200);
        const currentPrice = closes[0];
        const rsi = calculateRSI(closes, 14);
        const atr = calculateATR(highs, lows, closes, 14);

        return { 
          currentPrice, ema200, rsi, atr,
          candles: data.values.slice(0, 50).map(v => ({
            open: parseFloat(v.open),
            high: parseFloat(v.high),
            low: parseFloat(v.low),
            close: parseFloat(v.close)
          }))
        };
      } catch (err) {
        console.error(`Error for ${pair}:`, err);
        return null;
      }
    }

    // Indicators
    function calculateEMA(prices, period) {
      if (prices.length < period) return null;
      let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
      let multiplier = 2 / (period + 1);
      for (let i = period; i < prices.length; i++) {
        ema = (prices[i] - ema) * multiplier + ema;
      }
      return ema;
    }

    function calculateRSI(prices, period) {
      if (prices.length <= period) return 50;
      let gains = 0, losses = 0;
      for (let i = prices.length - period; i < prices.length - 1; i++) {
        const diff = prices[i + 1] - prices[i];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      gains /= period; losses /= period;
      if (losses === 0) return 100;
      return 100 - (100 / (1 + gains / losses));
    }

    function calculateATR(highs, lows, closes, period) {
      if (closes.length <= period) return 0.001;
      let trSum = 0;
      for (let i = closes.length - period; i < closes.length; i++) {
        const tr = Math.max(
          highs[i] - lows[i],
          Math.abs(highs[i] - (i > 0 ? closes[i - 1] : closes[i])),
          Math.abs(lows[i] - (i > 0 ? closes[i - 1] : closes[i]))
        );
        trSum += tr;
      }
      return trSum / period;
    }

    // AI Trend (simulated)
    let aiModel = null;
    async function loadAiModel() {
      if (aiModel) return aiModel;
      const model = tf.sequential();
      model.add(tf.layers.dense({ units: 32, inputShape: [30], activation: 'relu' }));
      model.add(tf.layers.dense({ units: 3, activation: 'softmax' }));
      model.compile({ optimizer: 'adam', loss: 'sparseCategoricalCrossentropy' });
      aiModel = model;
      return aiModel;
    }

    async function predictTrend(candles) {
      const recent = candles.slice(0, 5).map(c => c.close);
      const avgChange = recent.reduce((sum, val, i, arr) => sum + (val - (arr[i+1] || val)), 0) / 4;
      if (avgChange > 0) return { direction: "bull", confidence: 0.75 };
      else if (avgChange < 0) return { direction: "bear", confidence: 0.70 };
      else return { direction: "neutral", confidence: 0.55 };
    }

    // üî• MAIN SIGNAL GENERATOR WITH CHART PATTERNS
    async function generateSignals() {
      signalsDiv.innerHTML = "";
      loadingDiv.style.display = "block";
      lastUpdated.innerHTML = "";

      const signalCards = [];

      for (const pair of pairs) {
        const data = await fetchCandlesAndIndicators(pair);
        if (!data) {
          signalCards.push(`<div class="signal-card"><b>${pair}</b><br><span class="no-signal">‚ö†Ô∏è Data unavailable</span></div>`);
          continue;
        }

        const { currentPrice, ema200, rsi, atr, candles } = data;
        const pipSize = getPipSize(pair);
        const entry = currentPrice;
        let signalType = null;
        let slPips = null;

        // Volatility filter (relax slightly for chart patterns)
        const minATR = pair === "XAU/USD" ? 1.5 : pair === "USD/JPY" ? 0.12 : 0.0004;
        if (atr < minATR) {
          signalCards.push(`<div class="signal-card"><b>${pair}</b><br><span class="no-signal">‚è∏Ô∏è Low volatility ‚Äî skip</span></div>`);
          continue;
        }

        // Candlestick pattern
        const pattern = detectCandlestickSignal(candles);
        let patternName = "";
        let rsiBuyThreshold = 40;
        let rsiSellThreshold = 60;
        if (pattern) {
          if (pattern === "bullish_engulfing") { patternName = "Bullish Engulfing ‚úÖ"; rsiBuyThreshold = 45; }
          else if (pattern === "bearish_engulfing") { patternName = "Bearish Engulfing ‚ö†Ô∏è"; rsiSellThreshold = 55; }
          else if (pattern === "bullish_pin") { patternName = "Bullish Pin Bar üìå"; rsiBuyThreshold = 44; }
          else if (pattern === "bearish_pin") { patternName = "Bearish Pin Bar üìå"; rsiSellThreshold = 56; }
        }

        // AI Trend
        const aiPred = await predictTrend(candles);
        const { direction: aiDir, confidence: aiConf } = aiPred;

        // Generate base signal
        if (aiConf > 0.55) { // Slightly relaxed for patterns
          if (aiDir === "bull" && rsi < rsiBuyThreshold) {
            signalType = "BUY";
            slPips = Math.max(10, Math.round(atr / pipSize * 1.5));
          } else if (aiDir === "bear" && rsi > rsiSellThreshold) {
            signalType = "SELL";
            slPips = Math.max(10, Math.round(atr / pipSize * 1.5));
          }
        }

        if (!signalType) {
          signalCards.push(`<div class="signal-card"><b>${pair}</b><br><span class="no-signal">‚è∏Ô∏è No valid signal</span></div>`);
          continue;
        }

        // üî• MARKET STRUCTURE
        let structureTags = [];
        let structureBonus = 0;

        const swings = detectSwings(candles, 5);
        const nearSwingLow = swings.lows.some(low => Math.abs(entry - low) < 1.5 * atr);
        const nearSwingHigh = swings.highs.some(high => Math.abs(entry - high) < 1.5 * atr);
        if (signalType === "BUY" && nearSwingLow) {
          structureTags.push("Near Swing Low üìâ");
          structureBonus += 8;
        }
        if (signalType === "SELL" && nearSwingHigh) {
          structureTags.push("Near Swing High üìà");
          structureBonus += 8;
        }

        const fvgs = detectFVG(candles);
        const nearBullFVG = fvgs.some(f => f.type === "bullish" && entry > f.low && entry < f.low + 2 * atr);
        const nearBearFVG = fvgs.some(f => f.type === "bearish" && entry < f.high && entry > f.high - 2 * atr);
        if (signalType === "BUY" && nearBullFVG) {
          structureTags.push("FVG Support üü¢");
          structureBonus += 6;
        }
        if (signalType === "SELL" && nearBearFVG) {
          structureTags.push("FVG Resistance üî¥");
          structureBonus += 6;
        }

        const zones = detectSupplyDemand(candles, atr);
        const inDemand = zones.demand.some(z => entry >= z.low && entry <= z.high + 1.5 * atr);
        const inSupply = zones.supply.some(z => entry <= z.high && entry >= z.low - 1.5 * atr);
        if (signalType === "BUY" && inDemand) {
          structureTags.push("In Demand Zone ‚úÖ");
          structureBonus += 7;
        }
        if (signalType === "SELL" && inSupply) {
          structureTags.push("In Supply Zone ‚ö†Ô∏è");
          structureBonus += 7;
        }

        // üî• CHART PATTERNS - NEW CORE UPGRADE
        let chartPatternTags = [];
        let chartPatternBonus = 0;
        const chartPatterns = detectChartPatterns(candles, atr);
        const isGold = pair === "XAU/USD";

        // Only apply chart patterns to forex (you're happy with gold as-is)
        if (!isGold && chartPatterns.length > 0) {
          const cp = chartPatterns[0]; // Use first detected pattern
          if (cp === "double_top" && signalType === "SELL") {
            chartPatternTags.push("Double Top üìâ");
            chartPatternBonus += 12;
          } else if (cp === "double_bottom" && signalType === "BUY") {
            chartPatternTags.push("Double Bottom üìà");
            chartPatternBonus += 12;
          } else if (cp === "head_and_shoulders" && signalType === "SELL") {
            chartPatternTags.push("Head & Shoulders üìâ");
            chartPatternBonus += 15;
          } else if (cp === "ascending_triangle" && signalType === "BUY") {
            chartPatternTags.push("Ascending Triangle üìà");
            chartPatternBonus += 10;
          } else if (cp === "descending_triangle" && signalType === "SELL") {
            chartPatternTags.push("Descending Triangle üìâ");
            chartPatternBonus += 10;
          } else if (cp === "symmetrical_triangle" && ((signalType === "BUY" && aiDir === "bull") || (signalType === "SELL" && aiDir === "bear"))) {
            chartPatternTags.push("Symmetrical Triangle üî∫");
            chartPatternBonus += 9;
          } else if (cp === "bullish_flag" && signalType === "BUY") {
            chartPatternTags.push("Bullish Flag üö©");
            chartPatternBonus += 11;
          } else if (cp === "bearish_flag" && signalType === "SELL") {
            chartPatternTags.push("Bearish Flag üö©");
            chartPatternBonus += 11;
          } else if (cp === "cup_and_handle" && signalType === "BUY") {
            chartPatternTags.push("Cup & Handle ü´ñ");
            chartPatternBonus += 14;
          }
        }

        // Calculate SL/TP
        const slPrice = signalType === "BUY" ? entry - slPips * pipSize : entry + slPips * pipSize;
        const tpPips = Math.round(slPips * 1.5);
        const tpPrice = signalType === "BUY" ? entry + tpPips * pipSize : entry - tpPips * pipSize;

        // Position size
        const pipValue = pair === "XAU/USD" ? 0.10 : 10;
        const riskPerLot = slPips * pipValue;
        const lotSize = Math.max(0.01, Math.min(1.00, (RISK_AMOUNT / riskPerLot).toFixed(2)));

        // Confidence: AI + RSI + Candlestick + Structure + Chart Patterns
        const rsiStrength = signalType === "BUY" ? (rsiBuyThreshold - rsi) : (rsi - rsiSellThreshold);
        const baseConf = 50 + Math.min(30, rsiStrength * 2) + (aiConf * 30) + (pattern ? 12 : 0) + structureBonus + chartPatternBonus;
        const confidence = Math.min(95, Math.max(50, baseConf));
        const volClass = atr > (pair === "XAU/USD" ? 5 : pair === "USD/JPY" ? 0.3 : 0.0015) ? "high" : 
                         atr > (pair === "XAU/USD" ? 2 : pair === "USD/JPY" ? 0.15 : 0.0007) ? "medium" : "low";

        // Build UI
        let structureHtml = '';
        if (structureTags.length > 0) {
          structureHtml = `<span class="structure">${structureTags.join(' | ')}</span><br>`;
        }

        let chartPatternHtml = '';
        if (chartPatternTags.length > 0) {
          chartPatternHtml = `<span class="chart-pattern">${chartPatternTags.join(' | ')}</span><br>`;
        }

        signalCards.push(`
          <div class="signal-card">
            <b>${pair}</b> | <span style="color:${signalType==='BUY'?'#27ae60':'#e74c3c'}">${signalType}</span><br>
            Entry: ${formatPrice(entry, pair)} | SL: ${formatPrice(slPrice, pair)} | TP: ${formatPrice(tpPrice, pair)} | RR: 1.5<br>
            Lot Size: ${lotSize} | Risk: $${RISK_AMOUNT.toFixed(2)}<br>
            <span class="volatility ${volClass}">ATR Volatility</span><br>
            AI Trend: ${aiDir.toUpperCase()} (${Math.round(aiConf*100)}%)<br>
            ${patternName ? `<span class="pattern">${patternName}</span><br>` : ''}
            ${structureHtml}
            ${chartPatternHtml}
            Confidence: ${Math.round(confidence)}% 
            <div class="confidence-container">
              <div class="confidence-bar" style="width:${confidence}%"></div>
            </div>
          </div>
        `);
      }

      signalsDiv.innerHTML = signalCards.join('');
      loadingDiv.style.display = "none";
      const now = new Date();
      lastUpdated.innerHTML = `Last updated: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
    }

    (async () => {
      await loadAiModel();
      generateSignals();
    })();
  </script>
</body>
</html>
