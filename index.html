<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Forex Signal Analyzer ‚Äî All Hours, Simplified Logic</title>
  <style>
    body {
      font-family: "Poppins", Arial, sans-serif;
      background: #0a1224;
      color: #fff;
      margin: 0;
      padding: 0;
      text-align: center;
    }
    h1 {
      margin-top: 25px;
      font-size: 1.9em;
      color: #3cbefc;
    }
    button {
      background: #3cbefc;
      border: none;
      color: #fff;
      font-weight: bold;
      padding: 12px 24px;
      border-radius: 10px;
      cursor: pointer;
      margin-top: 15px;
      transition: 0.3s;
    }
    button:hover {
      background: #2ca2d8;
    }
    .signal-card {
      background: #121c36;
      margin: 15px auto;
      padding: 15px;
      width: 85%;
      max-width: 580px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      text-align: left;
    }
    .no-signal {
      color: #aaa;
      font-style: italic;
    }
    .volatility {
      font-weight: bold;
      padding: 6px 10px;
      border-radius: 8px;
      display: inline-block;
      margin-top: 6px;
    }
    .low { background: #27ae60; }
    .medium { background: #f1c40f; color: #000; }
    .high { background: #e74c3c; }
    .pattern, .structure, .chart-pattern, .quality {
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.9em;
      margin-top: 4px;
      display: inline-block;
    }
    .pattern { background: #9b59b6; color: white; }
    .structure { background: #3498db; color: white; }
    .chart-pattern { background: #e67e22; color: white; }
    .quality { background: #2ecc71; color: white; }
    .confidence-container {
      background: #2b3558;
      border-radius: 8px;
      margin-top: 8px;
      overflow: hidden;
      height: 10px;
      width: 100%;
    }
    .confidence-bar {
      height: 10px;
      transition: width 0.6s ease;
      background: linear-gradient(90deg, #ff3c3c, #f1c40f, #27ae60);
    }
    footer {
      margin: 20px 0;
      color: #ccc;
      font-size: 0.9em;
    }
    #loading {
      color: #3cbefc;
      margin-top: 20px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>AI Forex Signal Analyzer ‚Äî All Hours, Simplified Logic üìä</h1>
  <button onclick="generateSignals()">üîÑ Refresh Signals</button>
  <div id="loading" style="display:none;">Generating signals (all hours)...</div>
  <div id="signals"></div>
  <footer id="lastUpdated"></footer>

  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>

  <script>
    const pairs = ["EUR/USD", "GBP/USD", "USD/JPY", "AUD/USD", "XAU/USD"];
    const signalsDiv = document.getElementById("signals");
    const lastUpdated = document.getElementById("lastUpdated");
    const loadingDiv = document.getElementById("loading");
    const API_KEY = "318e2543fba14c57836adc5ce228ee7e"; // Your Twelve Data API key

    const symbolMap = {
      "EUR/USD": "EUR/USD",
      "GBP/USD": "GBP/USD",
      "USD/JPY": "USD/JPY",
      "AUD/USD": "AUD/USD",
      "XAU/USD": "XAU/USD"
    };

    // Account & risk settings
    const ACCOUNT_BALANCE = 1000;
    const RISK_PERCENT = 0.01;
    const RISK_AMOUNT = ACCOUNT_BALANCE * RISK_PERCENT;

    function getPipSize(pair) {
      return pair === "XAU/USD" || pair === "USD/JPY" ? 0.01 : 0.0001;
    }

    function formatPrice(price, pair) {
      const decimals = (pair === "USD/JPY" || pair === "XAU/USD") ? 2 : 5;
      return parseFloat(price).toFixed(decimals);
    }

    // üî• CANDLESTICK PATTERNS
    function detectCandlestickSignal(candles) {
      if (candles.length < 2) return null;
      const curr = candles[0], prev = candles[1];
      const currBody = Math.abs(curr.close - curr.open);
      const currWickTop = curr.high - Math.max(curr.open, curr.close);
      const currWickBottom = Math.min(curr.open, curr.close) - curr.low;

      if (curr.close > curr.open && prev.close < prev.open && curr.open < prev.close && curr.close > prev.open)
        return "bullish_engulfing";
      if (curr.close < curr.open && prev.close > prev.open && curr.open > prev.close && curr.close < prev.open)
        return "bearish_engulfing";
      if (currWickBottom > 2 * currBody && currWickTop < currBody)
        return "bullish_pin";
      if (currWickTop > 2 * currBody && currWickBottom < currBody)
        return "bearish_pin";
      return null;
    }

    // üî• MARKET STRUCTURE
    function detectSwings(candles, lookback = 5) {
      let swings = { highs: [], lows: [] };
      for (let i = lookback; i < candles.length - lookback; i++) {
        const isHigh = candles.slice(i - lookback, i + lookback + 1)
          .every((c, idx) => c.high <= candles[i].high || idx === lookback);
        if (isHigh) swings.highs.push(candles[i].high);
        const isLow = candles.slice(i - lookback, i + lookback + 1)
          .every((c, idx) => c.low >= candles[i].low || idx === lookback);
        if (isLow) swings.lows.push(candles[i].low);
      }
      return swings;
    }

    function detectFVG(candles) {
      const fvgZones = [];
      for (let i = 2; i < candles.length; i++) {
        const prev = candles[i];
        const mid = candles[i - 1];
        const next = candles[i - 2];
        if (mid.low > prev.high && mid.low > next.high) {
          fvgZones.push({ type: "bullish", low: mid.low, high: mid.high });
        } else if (mid.high < prev.low && mid.high < next.low) {
          fvgZones.push({ type: "bearish", low: mid.low, high: mid.high });
        }
      }
      return fvgZones;
    }

    function detectSupplyDemand(candles, atr) {
      const zones = { demand: [], supply: [] };
      for (let i = 3; i < candles.length - 3; i++) {
        const base = candles.slice(i, i + 3);
        const rangeHigh = Math.max(...base.map(c => c.high));
        const rangeLow = Math.min(...base.map(c => c.low));
        const range = rangeHigh - rangeLow;
        if (range < atr * 0.8) {
          const breakoutUp = candles[i - 1] && candles[i - 1].close > rangeHigh;
          const breakoutDown = candles[i - 1] && candles[i - 1].close < rangeLow;
          if (breakoutUp) zones.demand.push({ low: rangeLow, high: rangeHigh });
          if (breakoutDown) zones.supply.push({ low: rangeLow, high: rangeHigh });
        }
      }
      return zones;
    }

    // üî• CHART PATTERNS
    function detectChartPatterns(candles, atr) {
      const patterns = [];
      const n = candles.length;

      // Double Top / Bottom
      if (n >= 20) {
        const highs = candles.slice(0, 20).map(c => c.high);
        const lows = candles.slice(0, 20).map(c => c.low);
        const max1 = Math.max(...highs.slice(0, 10));
        const max2 = Math.max(...highs.slice(10, 20));
        const min1 = Math.min(...lows.slice(0, 10));
        const min2 = Math.min(...lows.slice(10, 20));
        if (Math.abs(max1 - max2) < atr * 1.5 && Math.abs(min1 - min2) < atr * 1.5) {
          if (candles[0].close < Math.min(max1, max2) - atr * 0.8) {
            patterns.push("double_top");
          } else if (candles[0].close > Math.max(min1, min2) + atr * 0.8) {
            patterns.push("double_bottom");
          }
        }
      }

      // Triangles
      if (n >= 15) {
        const recent = candles.slice(0, 15);
        const highs = recent.map(c => c.high);
        const lows = recent.map(c => c.low);
        const highestHigh = Math.max(...highs);
        const lowestLow = Math.min(...lows);
        const recentHigh = highs[0];
        const recentLow = lows[0];

        if (Math.abs(highestHigh - recentHigh) < atr * 0.3 && lows[0] > lows[5] + atr * 0.5) {
          patterns.push("ascending_triangle");
        }
        else if (Math.abs(lowestLow - recentLow) < atr * 0.3 && highs[0] < highs[5] - atr * 0.5) {
          patterns.push("descending_triangle");
        }
        else if (Math.abs(highestHigh - recentHigh) < atr * 0.5 && Math.abs(lowestLow - recentLow) < atr * 0.5) {
          patterns.push("symmetrical_triangle");
        }
      }

      // Flag
      if (n >= 10) {
        const move = candles[5].close - candles[9].close;
        const consolidation = Math.max(...candles.slice(0, 5).map(c => c.high)) - Math.min(...candles.slice(0, 5).map(c => c.low));
        if (Math.abs(move) > atr * 2 && consolidation < atr * 0.8) {
          if (move > 0) patterns.push("bullish_flag");
          else patterns.push("bearish_flag");
        }
      }

      return patterns;
    }

    // Fetch data
    async function fetchCandlesAndIndicators(pair) {
      const symbol = symbolMap[pair];
      if (!symbol) return null;
      const url = `https://api.twelvedata.com/time_series?symbol=${encodeURIComponent(symbol)}&interval=15min&outputsize=50&apikey=${API_KEY}`;
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        if (!data.values || data.values.length < 30) return null;

        const closes = data.values.map(v => parseFloat(v.close));
        const highs = data.values.map(v => parseFloat(v.high));
        const lows = data.values.map(v => parseFloat(v.low));
        const ema200 = calculateEMA(closes, 200);
        const currentPrice = closes[0];
        const rsi = calculateRSI(closes, 14);
        const atr = calculateATR(highs, lows, closes, 14);

        return { 
          currentPrice, ema200, rsi, atr,
          candles: data.values.slice(0, 50).map(v => ({
            open: parseFloat(v.open),
            high: parseFloat(v.high),
            low: parseFloat(v.low),
            close: parseFloat(v.close)
          }))
        };
      } catch (err) {
        console.error(`Error for ${pair}:`, err);
        return null;
      }
    }

    // Indicators
    function calculateEMA(prices, period) {
      if (prices.length < period) return null;
      let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
      let multiplier = 2 / (period + 1);
      for (let i = period; i < prices.length; i++) {
        ema = (prices[i] - ema) * multiplier + ema;
      }
      return ema;
    }

    function calculateRSI(prices, period) {
      if (prices.length <= period) return 50;
      let gains = 0, losses = 0;
      for (let i = prices.length - period; i < prices.length - 1; i++) {
        const diff = prices[i + 1] - prices[i];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      gains /= period; losses /= period;
      if (losses === 0) return 100;
      return 100 - (100 / (1 + gains / losses));
    }

    function calculateATR(highs, lows, closes, period) {
      if (closes.length <= period) return 0.001;
      let trSum = 0;
      for (let i = closes.length - period; i < closes.length; i++) {
        const tr = Math.max(
          highs[i] - lows[i],
          Math.abs(highs[i] - (i > 0 ? closes[i - 1] : closes[i])),
          Math.abs(lows[i] - (i > 0 ? closes[i - 1] : closes[i]))
        );
        trSum += tr;
      }
      return trSum / period;
    }

    // AI Trend (simulated)
    let aiModel = null;
    async function loadAiModel() {
      if (aiModel) return aiModel;
      const model = tf.sequential();
      model.add(tf.layers.dense({ units: 32, inputShape: [30], activation: 'relu' }));
      model.add(tf.layers.dense({ units: 3, activation: 'softmax' }));
      model.compile({ optimizer: 'adam', loss: 'sparseCategoricalCrossentropy' });
      aiModel = model;
      return aiModel;
    }

    async function predictTrend(candles) {
      const recent = candles.slice(0, 5).map(c => c.close);
      const avgChange = recent.reduce((sum, val, i, arr) => sum + (val - (arr[i+1] || val)), 0) / 4;
      if (avgChange > 0) return { direction: "bull", confidence: 0.75 };
      else if (avgChange < 0) return { direction: "bear", confidence: 0.70 };
      else return { direction: "neutral", confidence: 0.55 };
    }

    // üî• MAIN SIGNAL GENERATOR ‚Äî SIMPLIFIED LOGIC
    async function generateSignals() {
      signalsDiv.innerHTML = "";
      loadingDiv.style.display = "block";
      lastUpdated.innerHTML = "";

      const signalCards = [];

      for (const pair of pairs) {
        const data = await fetchCandlesAndIndicators(pair);
        if (!data) {
          signalCards.push(`<div class="signal-card"><b>${pair}</b><br><span class="no-signal">‚ö†Ô∏è Data unavailable</span></div>`);
          continue;
        }

        const { currentPrice, ema200, rsi, atr, candles } = data;
        const pipSize = getPipSize(pair);
        const entry = currentPrice;
        let signalType = null;
        let slPips = null;

        // üî• RELAXED VOLATILITY FILTER (works all hours)
        const minATR = pair === "XAU/USD" ? 1.0 : pair === "USD/JPY" ? 0.08 : 0.00025;
        if (atr < minATR) {
          signalCards.push(`<div class="signal-card"><b>${pair}</b><br><span class="no-signal">‚è∏Ô∏è Very low volatility ‚Äî try later</span></div>`);
          continue;
        }

        // üî• CORE LOGIC: AI + RSI ONLY ‚Üí ALWAYS GENERATES SIGNAL IF CONDITIONS MET
        const aiPred = await predictTrend(candles);
        const { direction: aiDir, confidence: aiConf } = aiPred;
        if (aiConf > 0.55) {
          if (aiDir === "bull" && rsi < 45) {
            signalType = "BUY";
            slPips = Math.max(8, Math.round(atr / pipSize * 1.5));
          } else if (aiDir === "bear" && rsi > 55) {
            signalType = "SELL";
            slPips = Math.max(8, Math.round(atr / pipSize * 1.5));
          }
        }

        if (!signalType) {
          signalCards.push(`<div class="signal-card"><b>${pair}</b><br><span class="no-signal">‚è∏Ô∏è No momentum (RSI neutral)</span></div>`);
          continue;
        }

        // Calculate SL/TP
        const slPrice = signalType === "BUY" ? entry - slPips * pipSize : entry + slPips * pipSize;
        const tpPips = Math.round(slPips * 1.5);
        const tpPrice = signalType === "BUY" ? entry + tpPips * pipSize : entry - tpPips * pipSize;

        // Position size
        const pipValue = pair === "XAU/USD" ? 0.10 : 10;
        const riskPerLot = slPips * pipValue;
        const lotSize = Math.max(0.01, Math.min(1.00, (RISK_AMOUNT / riskPerLot).toFixed(2)));

        // üî• CONFLUENCE DETECTION (for confidence only)
        let totalBonus = 0;
        let qualityTag = "Basic Setup";
        let extraTags = [];

        // Candlestick
        const candlePattern = detectCandlestickSignal(candles);
        if (candlePattern) {
          totalBonus += 12;
          let name = "";
          if (candlePattern === "bullish_engulfing") name = "Bullish Engulfing ‚úÖ";
          else if (candlePattern === "bearish_engulfing") name = "Bearish Engulfing ‚ö†Ô∏è";
          else if (candlePattern === "bullish_pin") name = "Bullish Pin Bar üìå";
          else if (candlePattern === "bearish_pin") name = "Bearish Pin Bar üìå";
          extraTags.push(`<span class="pattern">${name}</span>`);
        }

        // Market Structure
        const swings = detectSwings(candles, 5);
        const nearSwingLow = swings.lows.some(low => Math.abs(entry - low) < 1.5 * atr);
        const nearSwingHigh = swings.highs.some(high => Math.abs(entry - high) < 1.5 * atr);
        const fvgs = detectFVG(candles);
        const nearBullFVG = fvgs.some(f => f.type === "bullish" && entry > f.low && entry < f.low + 2 * atr);
        const nearBearFVG = fvgs.some(f => f.type === "bearish" && entry < f.high && entry > f.high - 2 * atr);
        if ((signalType === "BUY" && (nearSwingLow || nearBullFVG)) || 
            (signalType === "SELL" && (nearSwingHigh || nearBearFVG))) {
          totalBonus += 10;
          extraTags.push(`<span class="structure">Structure Align üåê</span>`);
        }

        // Chart Patterns (forex only)
        if (pair !== "XAU/USD") {
          const chartPatterns = detectChartPatterns(candles, atr);
          if (chartPatterns.length > 0) {
            totalBonus += 14;
            extraTags.push(`<span class="chart-pattern">Chart Pattern üìà</span>`);
          }
        }

        // Quality tag
        if (totalBonus >= 20) qualityTag = "High Confluence üåü";
        else if (totalBonus >= 10) qualityTag = "Price Action ‚úÖ";

        // Final confidence
        const rsiStrength = signalType === "BUY" ? (45 - rsi) : (rsi - 55);
        const baseConf = 55 + Math.min(25, rsiStrength * 2) + (aiConf * 25) + totalBonus;
        const confidence = Math.min(95, Math.max(50, baseConf));
        const volClass = atr > (pair === "XAU/USD" ? 5 : pair === "USD/JPY" ? 0.3 : 0.0015) ? "high" : 
                         atr > (pair === "XAU/USD" ? 2 : pair === "USD/JPY" ? 0.15 : 0.0007) ? "medium" : "low";

        // Build UI
        signalCards.push(`
          <div class="signal-card">
            <b>${pair}</b> | <span style="color:${signalType==='BUY'?'#27ae60':'#e74c3c'}">${signalType}</span><br>
            Entry: ${formatPrice(entry, pair)} | SL: ${formatPrice(slPrice, pair)} | TP: ${formatPrice(tpPrice, pair)} | RR: 1.5<br>
            Lot Size: ${lotSize} | Risk: $${RISK_AMOUNT.toFixed(2)}<br>
            <span class="volatility ${volClass}">ATR Volatility</span><br>
            <span class="quality">${qualityTag}</span><br>
            AI Trend: ${aiDir.toUpperCase()} (${Math.round(aiConf*100)}%)<br>
            ${extraTags.join('<br>')}
            Confidence: ${Math.round(confidence)}% 
            <div class="confidence-container">
              <div class="confidence-bar" style="width:${confidence}%"></div>
            </div>
          </div>
        `);
      }

      signalsDiv.innerHTML = signalCards.join('');
      loadingDiv.style.display = "none";
      const now = new Date();
      lastUpdated.innerHTML = `Last updated: ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
    }

    (async () => {
      await loadAiModel();
      generateSignals();
    })();
  </script>
</body>
</html>
