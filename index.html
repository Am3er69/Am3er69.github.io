<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Forex Signal Analyzer ‚Äî Scalp + Intraday + Swing (Single File)</title>
<style>
:root{--bg:#071126;--card:#0f2340;--accent:#2ad3a5;--muted:#9fb0c8;--gold:#d4af37;--danger:#ff6b6b}
body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6f0fa}
header{padding:12px 16px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid rgba(255,255,255,0.03)}
h1{margin:0;font-size:18px;color:var(--accent)}
.controls{display:flex;gap:8px}
button{background:var(--accent);color:#04202a;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700}
button.ghost{background:transparent;color:var(--accent);border:1px solid rgba(255,255,255,0.04)}
.wrap{padding:16px;display:flex;gap:16px;flex-wrap:wrap}
.panel{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(2,8,23,0.6)}
.panel.small{width:320px}
.panel.big{flex:1 1 760px;min-width:320px}
.small-muted{font-size:12px;color:#9fb0c8}
.input{background:transparent;border:1px solid rgba(255,255,255,0.05);padding:8px;border-radius:6px;color:#e6f0fa;width:100%}
.signal-card{border-radius:8px;padding:12px;margin-bottom:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border:1px solid rgba(255,255,255,0.03)}
.signal-card.hq{box-shadow:0 6px 24px rgba(212,175,55,0.12);border:1px solid rgba(212,175,55,0.22)}
.pair{display:flex;justify-content:space-between;align-items:center}
.chip{padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-weight:700}
.meta{font-size:13px;color:var(--muted);margin-top:6px;display:flex;gap:10px;flex-wrap:wrap}
.vol.low{background:#1a7a3c;color:#d7ffe9;padding:4px 8px;border-radius:6px}
.vol.mid{background:#f1c40f;color:#201600;padding:4px 8px;border-radius:6px}
.vol.high{background:#d63c3c;color:#fff;padding:4px 8px;border-radius:6px}
.conf-bar{height:8px;background:rgba(255,255,255,0.04);border-radius:6px;overflow:hidden;margin-top:8px}
.conf-fill{height:100%;background:linear-gradient(90deg,var(--danger),#ffd24d,var(--gold));width:0%;transition:width 600ms ease}
.footer{padding:12px;color:var(--muted);text-align:center;border-top:1px solid rgba(255,255,255,0.03);margin-top:12px}
.tag{display:inline-block;padding:4px 8px;border-radius:6px;background:rgba(255,255,255,0.02);margin-right:6px;font-size:12px}
.small-btn{padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--muted);cursor:pointer}
@media(max-width:900px){.wrap{flex-direction:column}.panel.small{width:100%}.panel.big{width:100%}}
</style>
</head>
<body>
<header>
  <h1>Forex Signal Analyzer ‚Äî Scalp ‚Ä¢ Intraday ‚Ä¢ Swing</h1>
  <div class="controls">
    <button onclick="manualRefresh()">üîÅ Refresh</button>
    <button class="ghost" onclick="openTracker()">Tracker</button>
  </div>
</header>

<div class="wrap">
  <div class="panel small">
    <div><strong>Settings</strong></div>
    <div class="small-muted">Balance & risk</div>
    <div style="margin-top:8px;">
      <label class="small-muted">Account (USD)</label><br>
      <input id="accountBalance" class="input" type="number" value="1000" min="10" />
    </div>
    <div style="margin-top:8px;">
      <label class="small-muted">Risk % per trade</label><br>
      <input id="riskPercent" class="input" type="number" value="1" step="0.1" min="0.1" />
    </div>

    <hr style="opacity:0.04;margin:12px 0" />
    <div><strong>Backtest</strong></div>
    <div class="small-muted">Light, per-signal (30 bars)</div>
    <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
      <label class="small-muted">Bars</label>
      <select id="backtestBars" class="input" style="width:110px"><option>25</option><option selected>30</option><option>35</option></select>
    </div>
    <div style="margin-top:10px;">
      <button class="ghost" onclick="runBacktestForAll()">‚ñ∂ Run Backtest (manual)</button>
    </div>

    <hr style="opacity:0.04;margin:12px 0" />
    <div><strong>Parameters</strong></div>
    <div class="small-muted">SL multiplier & Max SL</div>
    <div style="margin-top:8px;">
      <label class="small-muted">SL multiplier</label><br>
      <input id="slMultiplier" class="input" type="number" value="1.0" step="0.05" />
    </div>
    <div style="margin-top:8px;">
      <label class="small-muted">Max SL (pips, majors)</label><br>
      <input id="maxSlPips" class="input" type="number" value="30" />
    </div>

    <div style="margin-top:12px;">
      <button onclick="resetLocal()" class="ghost">Reset Local Data</button>
    </div>
    <div style="margin-top:12px;" class="small-muted">API delay: <span id="apiDelayLabel">1000ms</span></div>
  </div>

  <div class="panel big">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Signals ‚Äî all pairs</strong><div class="small-muted">Scalp (15m) ‚Ä¢ Intraday (1h) ‚Ä¢ Swing (1h/4h)</div></div>
      <div class="small-muted" id="lastUpdated">‚Äî</div>
    </div>

    <div id="signalsContainer" style="margin-top:12px"></div>
    <div id="backtestSummary" class="small-muted" style="margin-top:12px"></div>
  </div>
</div>

<!-- Tracker modal -->
<div id="trackerModal" style="display:none;position:fixed;inset:8% 6% 8% 6%;background:var(--card);border-radius:8px;padding:12px;z-index:99;overflow:auto">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <strong>Trade Tracker (local)</strong>
    <div><button class="ghost" onclick="closeTracker()">Close</button></div>
  </div>
  <div id="trackerList" style="margin-top:12px"></div>
  <div style="margin-top:10px"><button onclick="clearTracker()" class="ghost">Clear Tracker</button></div>
</div>

<footer class="footer">Configured for API efficiency: cached candles, adaptive throttling, and selective backtest for high-confidence signals. Test on demo first.</footer>

<script>
/* ================== CONFIG ================== */
// Your Twelve Data key (replace if needed)
const TD_KEY = "318e2543fba14c57836adc5ce228ee7e";

// Pairs list (you asked to remove USD/NZD and add EUR/JPY, GBP/JPY, EUR/GBP, GBP/AUD)
const PAIRS = ["EUR/USD","GBP/USD","USD/JPY","AUD/USD","USD/CAD","EUR/JPY","GBP/JPY","EUR/GBP","GBP/AUD","XAU/USD"];

// Intervals & limits
const INTERVAL_MAIN = "1h";
const INTERVAL_SCALP = "15min";
const BACKTEST_LIMIT = 30;
const MIN_ENTRY_PIPS = 5;   // smallest entry offset for majors
const MAX_ENTRY_PIPS = 15;  // closest intraday entry max
const RR_TARGET = 2.0;
const SPREAD_BUFFER_PIPS_MAJOR = 0.5;
const SPREAD_BUFFER_PIPS_XAU = 15;
const CACHE_TTL_MAIN_MS = 20 * 60 * 1000; // 20 minutes for 1H candles
const CACHE_TTL_SCALP_MS = 5 * 60 * 1000; // 5 minutes for 15m scalp candles
const AUTO_REFRESH_MINUTES = 5;

// Local storage keys
const SETTINGS_KEY = "fx_settings_v2";
const TRACKER_KEY = "fx_tracker_v2";
const BACKTEST_CACHE_KEY = "fx_bt_v2";

/* ================== STATE ================== */
let settings = loadSettings();
let API_DELAY_MS = 1000; // default 1000ms between pair fetches
let recentErrors = 0;

/* ================== UI hookup ================== */
document.getElementById("accountBalance").value = settings.accountBalance;
document.getElementById("riskPercent").value = settings.riskPercent;
document.getElementById("slMultiplier").value = settings.slMultiplier;
document.getElementById("maxSlPips").value = settings.maxSlPips;
document.getElementById("backtestBars").value = settings.backtestBars;
document.getElementById("apiDelayLabel").textContent = API_DELAY_MS + "ms";

["accountBalance","riskPercent","slMultiplier","maxSlPips","backtestBars"].forEach(id=>{
  document.getElementById(id).addEventListener("change", ()=>{
    settings.accountBalance = +document.getElementById("accountBalance").value || settings.accountBalance;
    settings.riskPercent = +document.getElementById("riskPercent").value || settings.riskPercent;
    settings.slMultiplier = +document.getElementById("slMultiplier").value || settings.slMultiplier;
    settings.maxSlPips = +document.getElementById("maxSlPips").value || settings.maxSlPips;
    settings.backtestBars = +document.getElementById("backtestBars").value || settings.backtestBars;
    saveSettings(settings);
  });
});

/* ================== HELPERS: storage, sleep, pip etc ================== */
function loadSettings(){ return Object.assign({accountBalance:1000,riskPercent:1,slMultiplier:1.0,maxSlPips:30,backtestBars:30}, JSON.parse(localStorage.getItem(SETTINGS_KEY)||"{}")); }
function saveSettings(s){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); }
function loadTracker(){ return JSON.parse(localStorage.getItem(TRACKER_KEY)||"[]"); }
function saveTracker(a){ localStorage.setItem(TRACKER_KEY, JSON.stringify(a)); }

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function pipSize(pair){ if(pair.includes("JPY")) return 0.01; if(pair==="XAU/USD") return 0.01; return 0.0001; }
function decimals(pair){ return (pair.includes("JPY")||pair==="XAU/USD")?2:5; }
function formatPrice(v,pair){ return (typeof v==="number"?v:parseFloat(v)).toFixed(decimals(pair)); }
function noteFetchError(){ recentErrors++; if(recentErrors>=3){ API_DELAY_MS = 2000; document.getElementById("apiDelayLabel").textContent = API_DELAY_MS + "ms"; console.warn("API errors rising, increased delay to", API_DELAY_MS); } }
function noteFetchSuccess(){ if(recentErrors>0) recentErrors--; if(recentErrors<=0){ recentErrors=0; API_DELAY_MS = 1000; document.getElementById("apiDelayLabel").textContent = API_DELAY_MS + "ms"; } }

/* ================== FETCH with retry & caching (localStorage) ================== */
async function fetchWithRetry(url, tries=2, wait=600){
  for(let i=0;i<tries;i++){
    try{
      const res = await fetch(url);
      if(!res.ok) throw new Error("HTTP " + res.status);
      const j = await res.json();
      return j;
    }catch(e){
      if(i===tries-1) throw e;
      await sleep(wait * Math.pow(2,i));
    }
  }
}

function cacheKey(pair, interval){ return `fx_cache_${pair.replace("/","_")}_${interval}`; }
function cacheMetaKey(pair, interval){ return `${cacheKey(pair,interval)}_meta`; }

async function tdCandlesCached(pair, bars, interval){
  const key = cacheKey(pair, interval);
  const metaKey = cacheMetaKey(pair, interval);
  const meta = JSON.parse(localStorage.getItem(metaKey) || "null");
  const cached = JSON.parse(localStorage.getItem(key) || "null");
  const now = Date.now();
  const ttl = (interval === INTERVAL_SCALP) ? CACHE_TTL_SCALP_MS : CACHE_TTL_MAIN_MS;

  if(cached && meta && (now - meta.fetchedAt < ttl) && cached.length >= bars){
    return cached.slice(0, bars);
  }

  // request
  try{
    const url = `https://api.twelvedata.com/time_series?symbol=${encodeURIComponent(pair)}&interval=${interval}&outputsize=${bars}&format=JSON&apikey=${TD_KEY}`;
    const j = await fetchWithRetry(url, 2, 600);
    if(j && j.values){
      const values = j.values.map(v=>({ time: v.datetime || v.timestamp, open:+v.open, high:+v.high, low:+v.low, close:+v.close }));
      localStorage.setItem(key, JSON.stringify(values));
      localStorage.setItem(metaKey, JSON.stringify({ fetchedAt: Date.now(), bars: values.length }));
      noteFetchSuccess();
      return values.slice(0, bars);
    } else {
      noteFetchError();
    }
  }catch(e){
    console.warn("tdCandlesCached fetch failed", pair, interval, e.message);
    noteFetchError();
  }

  // fallback to cached if available
  if(cached && cached.length>0) return cached.slice(0,bars);
  return null;
}

/* ================== INDICATORS & PATTERNS (kept and tuned) ================== */
function calcEMAFromArr(arr, period){
  if(!arr || arr.length < period) return null;
  const rev = arr.slice().reverse();
  let ema = rev.slice(0,period).reduce((a,b)=>a+b,0)/period;
  const k = 2/(period+1);
  for(let i=period;i<rev.length;i++) ema = (rev[i] - ema) * k + ema;
  return ema;
}
function calcATR(candles, period=14){
  if(!candles || candles.length <= period) return 0;
  let sum=0;
  for(let i=0;i<period;i++){
    const hi=candles[i].high, lo=candles[i].low, prev=(i+1<candles.length)?candles[i+1].close:candles[i].close;
    const tr = Math.max(hi-lo, Math.abs(hi-prev), Math.abs(lo-prev));
    sum += tr;
  }
  return sum/period;
}
function calcRSI(candles, period=14){
  if(!candles || candles.length <= period) return 50;
  let gains=0, losses=0;
  for(let i=0;i<period;i++){
    const diff = candles[i].close - (candles[i+1]?candles[i+1].close:candles[i].close);
    if(diff>0) gains+=diff; else losses -= diff;
  }
  if(losses===0) return 100;
  const avgGain=gains/period, avgLoss=losses/period;
  const rs = avgGain/avgLoss;
  return 100 - (100/(1+rs));
}
function detectCandles(candles){
  if(!candles || candles.length < 2) return null;
  const curr=candles[0], prev=candles[1];
  const currBody = Math.abs(curr.close - curr.open);
  const currWickTop = curr.high - Math.max(curr.open,curr.close);
  const currWickBottom = Math.min(curr.open,curr.close) - curr.low;
  if(curr.close>curr.open && prev.close<prev.open && curr.open < prev.close && curr.close > prev.open) return "bullish_engulfing";
  if(curr.close<curr.open && prev.close>prev.open && curr.open > prev.close && curr.close < prev.open) return "bearish_engulfing";
  if(currWickBottom > 2*currBody && currWickTop < currBody) return "bullish_pin";
  if(currWickTop > 2*currBody && currWickBottom < currBody) return "bearish_pin";
  return null;
}
function recentStructure(candles, lookback=24){
  const slice = (candles||[]).slice(0,lookback);
  if(slice.length===0) return {resistance:0,support:0};
  const highs = slice.map(c=>c.high), lows = slice.map(c=>c.low);
  return { resistance: Math.max(...highs), support: Math.min(...lows) };
}

/* ================== CORE SIGNAL BUILD (main logic preserved with tweaks) ================== */
function buildFromCandles(pair, candles, settingsLocal){
  try{
    if(!candles || candles.length < 20) return { valid:false, reason:"Insufficient data" };
    const currentPrice = candles[0].close;
    const closes = candles.map(c=>c.close);
    const ema50 = calcEMAFromArr(closes,50) || currentPrice;
    const ema200 = calcEMAFromArr(closes,200) || currentPrice;
    const rsi = calcRSI(candles,14);
    const atr = calcATR(candles,14);
    const pattern = detectCandles(candles);
    const struct = recentStructure(candles,24);
    const trend = ema50 > ema200 ? "up" : "down";

    let candidate = null;
    if(trend==="up" && rsi < 60){
      if(pattern==="bullish_engulfing" || pattern==="bullish_pin" || rsi < 50) candidate = "BUY";
    }
    if(trend==="down" && rsi > 40){
      if(pattern==="bearish_engulfing" || pattern==="bearish_pin" || rsi > 50) candidate = "SELL";
    }
    if(!candidate) return { valid:false, reason:"No confluence" };

    // intraday entry offset (keep entries near price 5-15 pips for majors, 20-40 for gold)
    const psize = pipSize(pair);
    const intradayMin = (pair==="XAU/USD") ? 20 : 5;
    const intradayMax = (pair==="XAU/USD") ? 40 : 10;
    const entryOffsetPips = intradayMin + Math.floor(Math.random() * (intradayMax - intradayMin + 1));
    const entry = candidate==="BUY" ? currentPrice - entryOffsetPips * psize : currentPrice + entryOffsetPips * psize;

    // dynamic SL (ATR * multiplier) and clamp to sensible bounds
    const atrPips = Math.max(1, Math.round(atr / psize));
    let slPips = Math.round(atrPips * (settingsLocal.slMultiplier || 1.0));
    if(slPips < intradayMin) slPips = intradayMin;
    if(slPips > (settingsLocal.maxSlPips || 60)) slPips = settingsLocal.maxSlPips || 60;
    if(pair==="XAU/USD" && slPips < 60) slPips = 60;

    const spreadBufPips = (pair==="XAU/USD") ? SPREAD_BUFFER_PIPS_XAU : SPREAD_BUFFER_PIPS_MAJOR;
    const spreadBuf = spreadBufPips * psize;

    const slPrice = candidate==="BUY" ? entry - slPips*psize - spreadBuf*psize : entry + slPips*psize + spreadBuf*psize;
    const tpPrice = candidate==="BUY" ? entry + slPips*psize*RR_TARGET : entry - slPips*psize*RR_TARGET;

    const account = settingsLocal.accountBalance || 1000;
    const riskUSD = account * (settingsLocal.riskPercent || 1) / 100;
    const pipDollar = (pair==="XAU/USD") ? 1.0 : (pair.includes("JPY") ? 9.0 : 10.0);
    const lots = Math.max(0.01, Math.round((riskUSD / (slPips * pipDollar)) * 100) / 100);

    // confidence scoring (preserve previous idea)
    let score = 0;
    score += ((trend==="up" && candidate==="BUY") || (trend==="down" && candidate==="SELL")) ? 25 : 0;
    score += pattern ? 20 : 0;
    score += Math.max(0, 15 - Math.abs(rsi - (candidate==="BUY"?45:55)));
    const structDist = candidate==="BUY" ? Math.abs(entry - struct.support) : Math.abs(struct.resistance - entry);
    const structPips = Math.round(structDist / psize);
    score += (structPips <= slPips) ? 10 : 0;
    score += Math.min(15, Math.round((atrPips / slPips) * 15));
    const internalConfidence = Math.min(95, Math.round(score));

    const isIntraday = entryOffsetPips <= intradayMax;

    return {
      valid:true,
      pair, candidate,
      entry, slPrice, tpPrice,
      slPips, tpPips: Math.round(Math.abs((tpPrice - entry) / psize)),
      lots, internalConfidence, atr, rsi, ema50, ema200, pattern, struct, lastCandleTime: candles[0].time, isIntraday
    };
  }catch(e){
    console.error("buildFromCandles error", e);
    return { valid:false, reason:"error" };
  }
}

/* ================== SCALP ANALYSIS (quick 15min pass) ================== */
async function analyzeScalp(pair){
  const candles = await tdCandlesCached(pair, 30, INTERVAL_SCALP).catch(()=>null);
  if(!candles || candles.length < 15) return null;
  const psize = pipSize(pair);
  const atr = calcATR(candles,14);
  const rsi = calcRSI(candles,7);
  const closes = candles.map(c=>c.close);
  const ema9 = calcEMAFromArr(closes,9) || closes[0];
  const ema21 = calcEMAFromArr(closes,21) || closes[0];
  const last = candles[0].close;

  // simple scalp rules
  if(ema9 > ema21 && rsi < 65 && last > ema9){
    const entry = last;
    const slPips = Math.max(4, Math.round((atr/psize) * 0.9));
    const tpPips = Math.max(6, Math.round(slPips * 1.6));
    const spreadBuf = (pair==="XAU/USD")? SPREAD_BUFFER_PIPS_XAU : SPREAD_BUFFER_PIPS_MAJOR;
    const slPrice = entry - slPips*psize - spreadBuf*psize;
    const tpPrice = entry + tpPips*psize;
    return { pair, type:"scalp", side:"BUY", entry, slPrice, tpPrice, slPips, tpPips, atr, rsi, ema9, ema21 };
  }
  if(ema9 < ema21 && rsi > 35 && last < ema9){
    const entry = last;
    const slPips = Math.max(4, Math.round((atr/psize) * 0.9));
    const tpPips = Math.max(6, Math.round(slPips * 1.6));
    const spreadBuf = (pair==="XAU/USD")? SPREAD_BUFFER_PIPS_XAU : SPREAD_BUFFER_PIPS_MAJOR;
    const slPrice = entry + slPips*psize + spreadBuf*psize;
    const tpPrice = entry - tpPips*psize;
    return { pair, type:"scalp", side:"SELL", entry, slPrice, tpPrice, slPips, tpPips, atr, rsi, ema9, ema21 };
  }
  return null;
}

/* ================== LIGHT BACKTEST (simulate) ================== */
function simulate(pair, candles, settingsLocal){
  if(!candles || candles.length < 20) return { total:0, wins:0, losses:0, winRate:0 };
  const rev = candles.slice().reverse();
  const psize = pipSize(pair);
  const results = [];
  for(let i=15;i<rev.length-1;i++){
    const window = rev.slice(0,i+1).reverse();
    const ema50 = calcEMAFromArr(window.map(c=>c.close),50) || window[0].close;
    const ema200 = calcEMAFromArr(window.map(c=>c.close),200) || window[0].close;
    const rsi = calcRSI(window,14);
    let sumDiff=0; for(let t=0;t<Math.min(5,window.length-1);t++) sumDiff += (window[t].close - (window[t+1]?window[t+1].close:window[t].close));
    const trendDir = sumDiff>0 ? "bull" : sumDiff<0 ? "bear" : "neutral";
    let candidate=null;
    if(trendDir==="bull" && window[0].close > ema200 && rsi < 60) candidate="BUY";
    if(trendDir==="bear" && window[0].close < ema200 && rsi > 40) candidate="SELL";
    if(!candidate) continue;
    const atr = calcATR(window,14);
    const atrPips = Math.max(1, Math.round(atr/psize));
    let slPips = Math.round(atrPips * (settingsLocal.slMultiplier || 1.0));
    if(slPips < 5) slPips = 5;
    if(slPips > settingsLocal.maxSlPips) slPips = settingsLocal.maxSlPips;
    let entry = candidate==="BUY" ? window[0].close - 5*psize : window[0].close + 5*psize;
    const spreadBuf = (pair==="XAU/USD") ? SPREAD_BUFFER_PIPS_XAU * psize : SPREAD_BUFFER_PIPS_MAJOR * psize;
    let slPrice = candidate==="BUY" ? entry - slPips*psize - spreadBuf : entry + slPips*psize + spreadBuf;
    let tpPrice = candidate==="BUY" ? entry + slPips*psize*RR_TARGET : entry - slPips*psize*RR_TARGET;
    let hit = null;
    for(let k=i+1;k<rev.length;k++){
      const h = rev[k].high, l = rev[k].low;
      if(candidate==="BUY"){
        if(l <= slPrice){ hit={type:"SL"}; break; }
        if(h >= tpPrice){ hit={type:"TP"}; break; }
      } else {
        if(h >= slPrice){ hit={type:"SL"}; break; }
        if(l <= tpPrice){ hit={type:"TP"}; break; }
      }
    }
    if(hit) results.push(hit);
  }
  const wins = results.filter(r=>r.type==="TP").length;
  const losses = results.filter(r=>r.type==="SL").length;
  const total = results.length || 0;
  const winRate = total ? Math.round((wins/total)*100) : 0;
  return { total, wins, losses, winRate };
}

/* ================== UI render helpers ================== */
function renderScalpCard(s){
  const conf = 55 + Math.min(35, s.rsi ? (s.side==="BUY"? (65 - s.rsi) : (s.rsi - 35)) : 0);
  const volClass = s.atr > (s.pair==="XAU/USD"?2: s.pair.includes("JPY")?0.05:0.0007) ? "vol.high" : "vol.mid";
  return `
    <div class="signal-card">
      <div class="pair"><div><strong>${s.pair}</strong> <span class="chip">SCALP</span> <span class="tag">${s.side}</span></div><div class="small-muted">Entry ${formatPrice(s.entry,s.pair)}</div></div>
      <div class="meta"><div>SL: <strong>${formatPrice(s.slPrice,s.pair)}</strong> (${s.slPips} pips)</div><div>TP: <strong>${formatPrice(s.tpPrice,s.pair)}</strong> (${s.tpPips} pips)</div></div>
      <div class="${volClass}" style="margin-top:8px">ATR:${s.atr.toFixed(decimals(s.pair))} RSI:${Math.round(s.rsi)}</div>
      <div style="margin-top:8px" class="small-muted">Scalp confidence: ${Math.round(conf)}%</div>
      <div class="conf-bar"><div class="conf-fill" style="width:${Math.round(conf)}%"></div></div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button onclick='markTaken(${JSON.stringify({pair:s.pair,side:s.side,entry:+s.entry,sl:+s.slPrice,tp:+s.tpPrice,slPips:s.slPips,tpPips:s.tpPips,lots:0.01})})'>‚úÖ Mark Taken</button>
      </div>
    </div>
  `;
}

/* ================== MAIN loop & rendering ================== */
const signalsContainer = document.getElementById("signalsContainer");
const lastUpdatedEl = document.getElementById("lastUpdated");
const backtestSummaryEl = document.getElementById("backtestSummary");

async function refreshAllSignals(){
  settings.accountBalance = +document.getElementById("accountBalance").value || settings.accountBalance;
  settings.riskPercent = +document.getElementById("riskPercent").value || settings.riskPercent;
  settings.slMultiplier = +document.getElementById("slMultiplier").value || settings.slMultiplier;
  settings.maxSlPips = +document.getElementById("maxSlPips").value || settings.maxSlPips;
  settings.backtestBars = +document.getElementById("backtestBars").value || settings.backtestBars;
  saveSettings(settings);

  signalsContainer.innerHTML = `<div class="small-muted">Fetching (cached) candles & computing signals... please wait</div>`;
  const built = [];
  const summaryRows = [];

  for(const pair of PAIRS){
    try{
      // scalp first (fast 15m) ‚Äî no heavy backtest here
      let scalp = null;
      try{ scalp = await analyzeScalp(pair); } catch(e){ scalp = null; }
      if(scalp) built.push(renderScalpCard(scalp));

      // gentle pacing to protect API
      await sleep(API_DELAY_MS);

      // main 1h candles (cached)
      const bars = Math.min(Math.max(settings.backtestBars || BACKTEST_LIMIT, 20), BACKTEST_LIMIT);
      const candles = await tdCandlesCached(pair, bars, INTERVAL_MAIN).catch(()=>null);
      if(!candles || candles.length < 20){
        built.push(`<div class="signal-card"><div class="pair"><strong>${pair}</strong></div><div class="small-muted">Data error (try refresh)</div></div>`);
        continue;
      }

      const sig = buildFromCandles(pair, candles, settings);
      if(!sig.valid){
        built.push(`<div class="signal-card"><div class="pair"><strong>${pair}</strong></div><div class="small-muted">${sig.reason || 'No signal'}</div></div>`);
        continue;
      }

      // run backtest only for high internalConfidence
      let bt = null;
      if(sig.internalConfidence >= 60){
        const existing = JSON.parse(localStorage.getItem(BACKTEST_CACHE_KEY + "_" + pair.replace("/","_")) || "null");
        const lastTimeKey = "fx_lasttime_" + pair.replace("/","_");
        const storedLast = localStorage.getItem(lastTimeKey);
        if(!existing || storedLast !== sig.lastCandleTime){
          // lightweight simulate on cached candles
          const summary = simulate(pair, candles, settings);
          bt = summary;
          localStorage.setItem(BACKTEST_CACHE_KEY + "_" + pair.replace("/","_"), JSON.stringify(summary));
          localStorage.setItem(lastTimeKey, sig.lastCandleTime);
        } else {
          bt = existing;
        }
      } else {
        const maybe = JSON.parse(localStorage.getItem(BACKTEST_CACHE_KEY + "_" + pair.replace("/","_")) || "null");
        if(maybe) bt = maybe;
      }

      const combined = bt && bt.total > 0 ? Math.round((sig.internalConfidence * 0.6) + (bt.winRate * 0.4)) : sig.internalConfidence;
      const isHQ = combined >= 65 && !!sig.pattern;
      const volClass = sig.atr > (pair==="XAU/USD" ? 2 : pair.includes("JPY") ? 0.05 : 0.0007) ? "vol.high" : "vol.mid";
      const cardClass = isHQ ? "signal-card hq" : "signal-card";

      const html = `
        <div class="${cardClass}">
          <div class="pair"><div><strong>${pair}</strong> <span class="chip">${sig.candidate}</span> ${isHQ?`<span style="background:linear-gradient(90deg,var(--gold),#ffd24d); color:#04202a; padding:4px 8px; border-radius:6px; font-weight:800; margin-left:8px">‚≠ê HQ</span>`:''}</div>
          <div class="small-muted">Entry ${formatPrice(sig.entry,pair)}</div></div>
          <div class="meta">
            <div>SL: <strong>${formatPrice(sig.slPrice,pair)}</strong> (${sig.slPips} pips)</div>
            <div>TP: <strong>${formatPrice(sig.tpPrice,pair)}</strong> (${sig.tpPips} pips)</div>
            <div>Lot: <strong>${sig.lots}</strong></div>
          </div>
          <div class="${volClass}" style="margin-top:8px">ATR:${sig.atr.toFixed(decimals(pair))} RSI:${Math.round(sig.rsi)} Pattern:${sig.pattern||'‚Äî'}</div>
          <div style="margin-top:8px" class="small-muted">Internal: ${sig.internalConfidence}% | Backtest Win: ${bt ? bt.winRate+'%' : 'N/A' } (samples ${bt?bt.total:0})</div>
          <div style="margin-top:6px" class="small-muted">Combined Confidence: ${combined}%</div>
          <div class="conf-bar"><div class="conf-fill" style="width:${combined}%"></div></div>
          <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
            <button onclick='markTaken(${JSON.stringify({pair:sig.pair,candidate:sig.candidate,entry:+sig.entry,sl:+sig.slPrice,tp:+sig.tpPrice,slPips:sig.slPips,tpPips:sig.tpPips,lots:sig.lots})})'>‚úÖ Mark Taken</button>
            <button onclick='openStructure(${JSON.stringify({pair:sig.pair,recent:sig.candles?sig.candles.slice(0,24):[]})})' class="ghost">Show Structure</button>
            <button onclick='runBacktest(${JSON.stringify(sig.pair)}, ${settings.backtestBars})' class="ghost">üß™ Backtest</button>
          </div>
        </div>
      `;
      built.push(html);
      summaryRows.push(`${pair}: win% ${bt ? bt.winRate : 'N/A'} (samples ${bt?bt.total:0})`);
    }catch(err){
      console.error("pair error",pair,err);
      built.push(`<div class="signal-card"><div class="pair"><strong>${pair}</strong></div><div class="small-muted">Data error</div></div>`);
      noteFetchError();
    }
    await sleep(API_DELAY_MS);
  }

  signalsContainer.innerHTML = built.join("");
  document.querySelectorAll('.conf-fill').forEach(e=>{ const w=e.style.width; e.style.width='0%'; setTimeout(()=>e.style.width=w,50); });
  lastUpdatedEl.textContent = `Last updated: ${new Date().toLocaleString()}`;
  backtestSummaryEl.textContent = summaryRows.join(" | ");
  noteFetchSuccess();
}

/* ================== tracker & utilities ================== */
function markTaken(obj){
  const t = loadTracker();
  const rec = { pair: obj.pair, side: obj.candidate || obj.side, entry:+obj.entry, sl:+obj.sl, tp:+obj.tp, lots:obj.lots || 0.01, takenAt:new Date().toISOString(), resolved:false };
  t.push(rec); localStorage.setItem(TRACKER_KEY, JSON.stringify(t));
  alert("Saved trade to local tracker.");
}
function openTracker(){
  const list = loadTracker();
  const container = document.getElementById("trackerList");
  if(!container) return;
  if(list.length===0) container.innerHTML = "<div class='small-muted'>No tracked trades yet.</div>";
  else container.innerHTML = list.map((t, idx)=>`<div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)"><strong>${t.pair}</strong> - ${t.side} - Taken: ${new Date(t.takenAt).toLocaleString()}<br>Entry:${t.entry} SL:${t.sl} TP:${t.tp}<br><button onclick='resolveTrade(${idx})'>Resolve</button></div>`).join("");
  document.getElementById("trackerModal").style.display = "block";
}
function closeTracker(){ document.getElementById("trackerModal").style.display = "none"; }
function clearTracker(){ if(confirm("Clear tracked trades?")){ localStorage.removeItem(TRACKER_KEY); alert("Cleared"); closeTracker(); } }
function resolveTrade(index){
  const list = loadTracker(); if(!list[index]) return alert("Not found");
  const outcome = prompt("Enter result: 'win' or 'loss'"); if(!outcome) return;
  const pips = prompt("Enter pips gained (positive) or lost (positive)"); const pipsNum = parseFloat(pips);
  if(isNaN(pipsNum)) return alert("Invalid pips");
  list[index].resolved = true; list[index].result = outcome.toLowerCase().startsWith("w") ? "win":"loss"; list[index].pips = pipsNum; list[index].resolvedAt = new Date().toISOString();
  localStorage.setItem(TRACKER_KEY, JSON.stringify(list));
  alert("Saved resolution.");
}

/* ================== backtest controls ================== */
async function runBacktest(pair, bars){
  try{
    const barsNum = Math.min(bars || settings.backtestBars || BACKTEST_LIMIT, BACKTEST_LIMIT);
    const candles = await tdCandlesCached(pair, barsNum, INTERVAL_MAIN).catch(()=>null);
    if(!candles) return alert("Backtest failed: no historical data (or API limit). Try fewer bars.");
    const summary = simulate(pair, candles, settings);
    alert(`${pair} backtest ‚Äî samples: ${summary.total}\nWins: ${summary.wins}\nLosses: ${summary.losses}\nWinRate: ${summary.winRate}%`);
    localStorage.setItem(BACKTEST_CACHE_KEY + "_" + pair.replace("/","_"), JSON.stringify(summary));
  }catch(e){ console.error(e); alert("Backtest error (see console)"); }
}

async function runBacktestForAll(){
  const rows=[];
  for(const p of PAIRS){
    try{
      const c = await tdCandlesCached(p, settings.backtestBars || BACKTEST_LIMIT, INTERVAL_MAIN).catch(()=>null);
      if(!c){ rows.push(`${p}: no data`); continue; }
      const s = simulate(p, c, settings);
      rows.push(`${p}: win% ${s.winRate} (samples ${s.total})`);
      localStorage.setItem(BACKTEST_CACHE_KEY + "_" + p.replace("/","_"), JSON.stringify(s));
    }catch(e){ rows.push(`${p}: error`); }
    await sleep(250);
  }
  document.getElementById("backtestSummary").textContent = rows.join(" | ");
  alert("Backtest complete ‚Äî summary shown on page.");
}

/* ================== misc ================== */
function openStructure(obj){ alert(JSON.stringify(obj).slice(0,1500)); }
function resetLocal(){ if(confirm("Reset local storage?")){ localStorage.removeItem(SETTINGS_KEY); localStorage.removeItem(TRACKER_KEY); PAIRS.forEach(p=>{ localStorage.removeItem(`fx_cache_${p.replace("/","_")}_${INTERVAL_MAIN}`); localStorage.removeItem(`fx_cache_${p.replace("/","_")}_${INTERVAL_MAIN}_meta`); localStorage.removeItem(`fx_cache_${p.replace("/","_")}_${INTERVAL_SCALP}`); localStorage.removeItem(`fx_cache_${p.replace("/","_")}_${INTERVAL_SCALP}_meta`); localStorage.removeItem(BACKTEST_CACHE_KEY + "_" + p.replace("/","_")); localStorage.removeItem("fx_lasttime_"+p.replace("/","_")); }); location.reload(); } }

async function manualRefresh(){ await refreshAllSignals().catch(e=>console.error(e)); }

/* ================== init loop ================== */
(async ()=>{
  try{ await refreshAllSignals(); }catch(e){ console.error(e); }
  setInterval(()=>{ refreshAllSignals().catch(e=>console.error(e)); }, AUTO_REFRESH_MINUTES * 60 * 1000);
})();
</script>
</body>
</html>
