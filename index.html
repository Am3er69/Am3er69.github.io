<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Forex Trader Pro - R1000</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 12px;
      background: #f5f5f5;
      color: #333;
    }
    h2 {
      margin-top: 16px;
      color: #2c3e50;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 16px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .trade-card {
      padding: 12px;
      border-radius: 6px;
      margin-top: 12px;
      font-size: 0.95em;
      background: #f8f9fa;
      border-left: 4px solid #27ae60;
    }
    .loading { color: #3498db; }
    .error { 
      color: #e74c3c;
      background: #fadbd8;
      padding: 10px;
      border-radius: 6px;
    }
    .best-trade {
      border-left-color: #8e44ad;
      background: #f5eefc;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>🔥 Daily Trading Weapon (R1000 Optimized)</h2>
    <p class="loading" id="status">📡 Fetching real 1H & 4H market data...</p>
    <div id="tradesContainer"></div>
  </div>

  <script>
    const API_KEY = 'ec47de8969cb431b8ea24453c5c989f1';
    const PAIRS = ['EUR/USD', 'GBP/USD', 'USD/JPY', 'AUD/USD', 'USD/CAD', 'USD/CHF'];
    const ACCOUNT_BALANCE = 1000; // R1000
    const RISK_PERCENT = 1; // 1% risk per trade

    // === TRADING SESSION ===
    function getCurrentSession() {
      const hour = new Date().getUTCHours();
      if (hour >= 7 && hour < 15) return 'London';
      if (hour >= 12 && hour < 21) return 'New York';
      return 'Asian';
    }

    function isPairActiveInSession(pair, session) {
      if (session === 'London') return pair.includes('EUR') || pair.includes('GBP') || pair.includes('CHF');
      if (session === 'New York') return pair.includes('USD') || pair.includes('CAD');
      if (session === 'Asian') return pair.includes('JPY') || pair.includes('AUD') || pair.includes('NZD');
      return true;
    }

    // === MATH HELPERS ===
    const sma = (data, p) => {
      const avg = [];
      for (let i = p - 1; i < data.length; i++) {
        avg.push(data.slice(i - p + 1, i + 1).reduce((a, b) => a + b, 0) / p);
      }
      return avg;
    };

    const ema = (data, p) => {
      const k = 2 / (p + 1);
      const e = [data[0]];
      for (let i = 1; i < data.length; i++) e.push(data[i] * k + e[i - 1] * (1 - k));
      return e;
    };

    const rsi = (prices, p = 14) => {
      const deltas = prices.slice(1).map((v, i) => v - prices[i]);
      const gains = deltas.map(d => d > 0 ? d : 0);
      const losses = deltas.map(d => d < 0 ? -d : 0);
      const avgGain = sma(gains, p);
      const avgLoss = sma(losses, p);
      return avgGain.map((g, i) => 100 - (100 / (1 + (g / (avgLoss[i] || 1)))));
    };

    const atr = (high, low, close, p = 14) => {
      const tr = [high[0] - low[0]];
      for (let i = 1; i < high.length; i++) {
        tr.push(Math.max(high[i] - low[i], Math.abs(high[i] - close[i - 1]), Math.abs(low[i] - close[i - 1])));
      }
      return sma(tr, p);
    };

    // === FETCH CANDLES (ANY TIMEFRAME) ===
    async function fetchCandles(pair, interval) {
      const symbol = pair.replace('/', '');
      const url = `https://api.twelvedata.com/time_series?symbol=${symbol}&interval=${interval}&outputsize=200&apikey=${API_KEY}`;
      try {
        const res = await fetch(url);
        const data = await res.json();
        if (data.values) {
          return {
            close: data.values.map(v => parseFloat(v.close)).reverse(),
            high: data.values.map(v => parseFloat(v.high)).reverse(),
            low: data.values.map(v => parseFloat(v.low)).reverse()
          };
        }
      } catch (e) {
        console.error(`Failed ${pair} ${interval}:`, e);
      }
      return null;
    }

    // === NEWS FILTER (SIMULATED HIGH-IMPACT) ===
    function isHighImpactNewsWindow(pair) {
      const now = new Date();
      const day = now.getDate();
      const dayOfWeek = now.getDay();
      const hour = now.getUTCHours();
      const minute = now.getUTCMinutes();
      const timeInMinutes = hour * 60 + minute;

      // NFP: First Friday, ~12:30 UTC
      if (dayOfWeek === 5 && day <= 7 && Math.abs(timeInMinutes - (12*60 + 30)) <= 30) {
        return pair.includes('USD');
      }
      // CPI: ~12:30 UTC between 10th–15th
      if (day >= 10 && day <= 15 && Math.abs(timeInMinutes - (12*60 + 30)) <= 30) {
        return pair.includes('USD');
      }
      return false;
    }

    // === MAIN ANALYSIS ===
    async function analyzePair(pair) {
      const session = getCurrentSession();
      if (!isPairActiveInSession(pair, session)) return [];

      if (isHighImpactNewsWindow(pair)) return [];

      const candles1h = await fetchCandles(pair, '1h');
      const candles4h = await fetchCandles(pair, '4h');
      if (!candles1h || !candles4h) return [];

      // 4H Trend Filter
      const ema50_4h = ema(candles4h.close, 50);
      const ema200_4h = ema(candles4h.close, 200);
      const higherTrend = ema50_4h.at(-1) > ema200_4h.at(-1) ? 'up' : 'down';

      // 1H Indicators
      const c = candles1h.close;
      const h = candles1h.high;
      const l = candles1h.low;
      const ema50 = ema(c, 50);
      const ema200 = ema(c, 200);
      const rsis = rsi(c, 14);
      const atrs = atr(h, l, c, 14);

      const latestClose = c.at(-1);
      const latestEma50 = ema50.at(-1);
      const latestEma200 = ema200.at(-1);
      const latestRsi = rsis.at(-1);
      const latestAtr = atrs.at(-1);
      const atrAvg = atrs.slice(-20).reduce((a, b) => a + b, 0) / 20;

      // Volatility Zone Filter
      if (latestAtr > atrAvg * 1.8 || latestAtr < atrAvg * 0.5) return [];

      // Candle Pattern
      const prevHigh = h.at(-2);
      const prevLow = l.at(-2);
      const bullishCandle = latestClose > prevHigh;
      const bearishCandle = latestClose < prevLow;

      const isUptrend = latestEma50 > latestEma200;
      const isDowntrend = latestEma50 < latestEma200;

      const trades = [];
      const pipSize = pair.includes('JPY') ? 0.01 : 0.0001;

      // BUY
      if (isUptrend && higherTrend === 'up' && bullishCandle && latestRsi > 55) {
        const sl = latestClose - latestAtr;
        const tp = latestClose + latestAtr * 2;
        const slPips = Math.abs(latestClose - sl) / pipSize;
        const tpPips = Math.abs(tp - latestClose) / pipSize;
        const rr = tpPips / slPips;
        if (rr >= 1.5) {
          let score = 0;
          score += 25; // trend
          score += 20; // higher TF
          score += 25; // candle
          score += 15; // RSI
          score += Math.min(15, (rr - 1.5) * 10); // R:R bonus
          const winProb = Math.min(95, score);

          const riskAmount = (ACCOUNT_BALANCE * RISK_PERCENT) / 100;
          const microLots = riskAmount / (slPips * 0.10);

          trades.push({ pair, direction: 'buy', entry: latestClose, sl, tp, slPips, tpPips, rr, winProb, microLots });
        }
      }

      // SELL
      if (isDowntrend && higherTrend === 'down' && bearishCandle && latestRsi < 45) {
        const sl = latestClose + latestAtr;
        const tp = latestClose - latestAtr * 2;
        const slPips = Math.abs(sl - latestClose) / pipSize;
        const tpPips = Math.abs(latestClose - tp) / pipSize;
        const rr = tpPips / slPips;
        if (rr >= 1.5) {
          let score = 0;
          score += 25; // trend
          score += 20; // higher TF
          score += 25; // candle
          score += 15; // RSI
          score += Math.min(15, (rr - 1.5) * 10);
          const winProb = Math.min(95, score);

          const riskAmount = (ACCOUNT_BALANCE * RISK_PERCENT) / 100;
          const microLots = riskAmount / (slPips * 0.10);

          trades.push({ pair, direction: 'sell', entry: latestClose, sl, tp, slPips, tpPips, rr, winProb, microLots });
        }
      }

      return trades;
    }

    // === RUN ANALYSIS ===
    async function generateDailySignals() {
      document.getElementById('status').textContent = `🔍 Analyzing 6 pairs (1H + 4H) • Session: ${getCurrentSession()}`;
      let allTrades = [];

      for (const pair of PAIRS) {
        const trades = await analyzePair(pair);
        allTrades = allTrades.concat(trades);
        await new Promise(r => setTimeout(r, 100)); // rate limit
      }

      allTrades.sort((a, b) => b.winProb - a.winProb);
      const top3 = allTrades.slice(0, 3);

      const container = document.getElementById('tradesContainer');
      if (top3.length === 0) {
        container.innerHTML = '<div class="error">🚫 No high-quality setups today. Market conditions not optimal.</div>';
        document.getElementById('status').textContent = '✅ Daily analysis complete';
      } else {
        let html = `<p>🎯 <b>Top ${top3.length} Trades for Today</b> (R1000 • 1% Risk)</p>`;
        top3.forEach((t, i) => {
          const dir = t.direction === 'buy' ? '🟢 BUY' : '🔴 SELL';
          const decimals = t.pair.includes('JPY') ? 3 : 5;
          const isBest = i === 0;
          html += `
            <div class="trade-card ${isBest ? 'best-trade' : ''}">
              <b>#${i+1} • ${t.pair} • ${dir}</b> (${t.winProb}% confidence)
              <div>Entry: ${t.entry.toFixed(decimals)} | SL: ${t.sl.toFixed(decimals)} (${t.slPips}p) | TP: ${t.tp.toFixed(decimals)} (${t.tpPips}p)</div>
              <div>R:R = 1:${t.rr} | Position: ${t.microLots.toFixed(1)} micro lots (R${(ACCOUNT_BALANCE * RISK_PERCENT / 100).toFixed(0)} risk)</div>
            </div>
          `;
        });
        container.innerHTML = html;
        document.getElementById('status').textContent = `✅ Ready: ${top3.length} high-conviction trades`;
      }
    }

    // === START ===
    generateDailySignals();
  </script>
</body>
</html>
