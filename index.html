<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Forex Trader Pro - R1000</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 12px;
      background: #f5f5f5;
      color: #333;
    }
    h2 {
      margin-top: 16px;
      color: #2c3e50;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 16px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .trade-card {
      padding: 12px;
      border-radius: 6px;
      margin-top: 12px;
      font-size: 0.95em;
      background: #f8f9fa;
      border-left: 4px solid #27ae60;
    }
    .loading { color: #3498db; }
    .error { 
      color: #e74c3c;
      background: #fadbd8;
      padding: 10px;
      border-radius: 6px;
    }
    .session-info {
      font-size: 0.9em;
      color: #7f8c8d;
      margin-bottom: 8px;
    }
    button {
      margin: 16px auto;
      display: block;
      padding: 10px 20px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
    }
    button:disabled {
      background: #bdc3c7;
      cursor: not-allowed;
    }
    #backtestResults {
      margin-top: 20px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>🔥 Daily Trading Signals (R1000 Optimized)</h2>
    <div class="session-info">Session: <span id="sessionLabel">Loading...</span></div>
    <p class="loading" id="status">📡 Fetching real 1H & 4H market data...</p>
    <div id="tradesContainer"></div>
  </div>

  <button id="backtestBtn" onclick="runBacktest()">
    📊 Run Backtest (Last 90 Days)
  </button>
  <div id="backtestResults"></div>

  <script>
    const API_KEY = 'ec47de8969cb431b8ea24453c5c989f1';
    const PAIRS = [
      'EUR/USD', 'GBP/USD', 'USD/JPY',
      'AUD/USD', 'USD/CAD', 'USD/CHF',
      'XAU/USD'
    ];
    const ACCOUNT_BALANCE = 1000;
    const RISK_PERCENT = 1;

    // === TRADING SESSION ===
    function getCurrentSession() {
      const hour = new Date().getUTCHours();
      if (hour >= 7 && hour < 15) return 'London';
      if (hour >= 12 && hour < 21) return 'New York';
      return 'Asian';
    }

    function isPairActiveInSession(pair, session) {
      if (session === 'London') return pair.includes('EUR') || pair.includes('GBP') || pair.includes('CHF') || pair.includes('XAU');
      if (session === 'New York') return pair.includes('USD') || pair.includes('CAD') || pair.includes('XAU');
      if (session === 'Asian') return pair.includes('JPY') || pair.includes('AUD') || pair.includes('NZD');
      return true;
    }

    // === MATH HELPERS ===
    const sma = (data, p) => {
      const avg = [];
      for (let i = p - 1; i < data.length; i++) {
        avg.push(data.slice(i - p + 1, i + 1).reduce((a, b) => a + b, 0) / p);
      }
      return avg;
    };

    const ema = (data, p) => {
      const k = 2 / (p + 1);
      const e = [data[0]];
      for (let i = 1; i < data.length; i++) e.push(data[i] * k + e[i - 1] * (1 - k));
      return e;
    };

    const rsi = (prices, p = 14) => {
      const deltas = prices.slice(1).map((v, i) => v - prices[i]);
      const gains = deltas.map(d => d > 0 ? d : 0);
      const losses = deltas.map(d => d < 0 ? -d : 0);
      const avgGain = sma(gains, p);
      const avgLoss = sma(losses, p);
      return avgGain.map((g, i) => 100 - (100 / (1 + (g / (avgLoss[i] || 1)))));
    };

    const atr = (high, low, close, p = 14) => {
      const tr = [high[0] - low[0]];
      for (let i = 1; i < high.length; i++) {
        tr.push(Math.max(high[i] - low[i], Math.abs(high[i] - close[i - 1]), Math.abs(low[i] - close[i - 1])));
      }
      return sma(tr, p);
    };

    // === FETCH CANDLES (LIVE) ===
    async function fetchCandles(pair, interval) {
      const symbol = pair.replace('/', '');
      const url = `https://api.twelvedata.com/time_series?symbol=${symbol}&interval=${interval}&outputsize=200&apikey=${API_KEY}`;
      try {
        const res = await fetch(url);
        const data = await res.json();
        if (data.values) {
          return {
            close: data.values.map(v => parseFloat(v.close)).reverse(),
            high: data.values.map(v => parseFloat(v.high)).reverse(),
            low: data.values.map(v => parseFloat(v.low)).reverse()
          };
        }
      } catch (e) {
        console.error(`Failed ${pair} ${interval}:`, e);
      }
      return null;
    }

    // === NEWS FILTER ===
    function isHighImpactNewsWindow(pair) {
      const now = new Date();
      const day = now.getDate();
      const dayOfWeek = now.getDay();
      const hour = now.getUTCHours();
      const minute = now.getUTCMinutes();
      const timeInMinutes = hour * 60 + minute;

      if (dayOfWeek === 5 && day <= 7 && Math.abs(timeInMinutes - (12*60 + 30)) <= 30) return pair.includes('USD');
      if (day >= 10 && day <= 15 && Math.abs(timeInMinutes - (12*60 + 30)) <= 30) return pair.includes('USD');
      return false;
    }

    // === PIP SIZE HELPER ===
    function getPipSize(pair) {
      if (pair.includes('JPY')) return 0.01;
      if (pair.includes('XAU')) return 0.1;
      return 0.0001;
    }

    // === BUILD TRADE OBJECT ===
    function buildTrade(pair, direction, entry, sl, tp, slPips, tpPips, rr, scoreBonus = 0) {
      const riskAmount = (ACCOUNT_BALANCE * RISK_PERCENT) / 100;
      const pipSize = getPipSize(pair);
      const microLots = riskAmount / (slPips * 0.10);
      let score = 0;
      score += 25;
      score += 20;
      score += 15;
      score += Math.min(20, (rr - 1.0) * 12);
      score += scoreBonus;
      const winProb = Math.min(95, score);
      let confidence = "Low";
      if (winProb >= 70) confidence = "High";
      else if (winProb >= 55) confidence = "Medium";
      return { pair, direction, entry, sl, tp, slPips, tpPips, rr, winProb, confidence, microLots };
    }

    // === STRICT ANALYSIS ===
    async function analyzePairStrict(pair) {
      const session = getCurrentSession();
      if (!isPairActiveInSession(pair, session)) return [];
      if (isHighImpactNewsWindow(pair)) return [];

      const candles1h = await fetchCandles(pair, '1h');
      const candles4h = await fetchCandles(pair, '4h');
      if (!candles1h || !candles4h) return [];

      const ema50_4h = ema(candles4h.close, 50);
      const ema200_4h = ema(candles4h.close, 200);
      const higherTrend = ema50_4h.at(-1) > ema200_4h.at(-1) ? 'up' : 'down';

      const c = candles1h.close;
      const h = candles1h.high;
      const l = candles1h.low;
      const ema50 = ema(c, 50);
      const ema200 = ema(c, 200);
      const rsis = rsi(c, 14);
      const atrs = atr(h, l, c, 14);

      const latestClose = c.at(-1);
      const latestEma50 = ema50.at(-1);
      const latestEma200 = ema200.at(-1);
      const latestRsi = rsis.at(-1);
      const latestAtr = atrs.at(-1);
      const atrAvg = atrs.slice(-20).reduce((a, b) => a + b, 0) / 20;

      if (latestAtr > atrAvg * 2.2 || latestAtr < atrAvg * 0.35) return [];

      const prevHigh = h.at(-2);
      const prevLow = l.at(-2);
      const bullishCandle = latestClose > prevHigh;
      const bearishCandle = latestClose < prevLow;

      const isUptrend = latestEma50 > latestEma200;
      const isDowntrend = latestEma50 < latestEma200;
      const pipSize = getPipSize(pair);
      const trades = [];

      if (isUptrend && higherTrend === 'up' && bullishCandle && latestRsi > 50) {
        const sl = latestClose - latestAtr;
        const tp = latestClose + latestAtr * 2;
        const slPips = Math.abs(latestClose - sl) / pipSize;
        const tpPips = Math.abs(tp - latestClose) / pipSize;
        const rr = tpPips / slPips;
        if (rr >= 1.2) trades.push(buildTrade(pair, 'buy', latestClose, sl, tp, slPips, tpPips, rr, 10));
      }

      if (isDowntrend && higherTrend === 'down' && bearishCandle && latestRsi < 50) {
        const sl = latestClose + latestAtr;
        const tp = latestClose - latestAtr * 2;
        const slPips = Math.abs(sl - latestClose) / pipSize;
        const tpPips = Math.abs(latestClose - tp) / pipSize;
        const rr = tpPips / slPips;
        if (rr >= 1.2) trades.push(buildTrade(pair, 'sell', latestClose, sl, tp, slPips, tpPips, rr, 10));
      }

      if (isUptrend && higherTrend === 'up' && latestRsi > 55 && latestRsi < 70) {
        const sl = latestEma50;
        const tp = latestClose + latestAtr * 1.8;
        const slPips = Math.abs(latestClose - sl) / pipSize;
        const tpPips = Math.abs(tp - latestClose) / pipSize;
        const rr = tpPips / slPips;
        if (rr >= 1.2) trades.push(buildTrade(pair, 'buy', latestClose, sl, tp, slPips, tpPips, rr, 0));
      }

      if (isDowntrend && higherTrend === 'down' && latestRsi < 45 && latestRsi > 30) {
        const sl = latestEma50;
        const tp = latestClose - latestAtr * 1.8;
        const slPips = Math.abs(sl - latestClose) / pipSize;
        const tpPips = Math.abs(latestClose - tp) / pipSize;
        const rr = tpPips / slPips;
        if (rr >= 1.2) trades.push(buildTrade(pair, 'sell', latestClose, sl, tp, slPips, tpPips, rr, 0));
      }

      return trades;
    }

    // === RELAXED ANALYSIS ===
    async function analyzePairRelaxed(pair) {
      const session = getCurrentSession();
      if (!isPairActiveInSession(pair, session)) return [];

      const candles1h = await fetchCandles(pair, '1h');
      const candles4h = await fetchCandles(pair, '4h');
      if (!candles1h || !candles4h) return [];

      const ema50_4h = ema(candles4h.close, 50);
      const ema200_4h = ema(candles4h.close, 200);
      const higherTrend = ema50_4h.at(-1) > ema200_4h.at(-1) ? 'up' : 'down';

      const c = candles1h.close;
      const h = candles1h.high;
      const l = candles1h.low;
      const ema50 = ema(c, 50);
      const ema200 = ema(c, 200);
      const rsis = rsi(c, 14);
      const atrs = atr(h, l, c, 14);

      const latestClose = c.at(-1);
      const latestEma50 = ema50.at(-1);
      const latestEma200 = ema200.at(-1);
      const latestRsi = rsis.at(-1);
      const latestAtr = atrs.at(-1);
      const atrAvg = atrs.slice(-20).reduce((a, b) => a + b, 0) / 20;

      if (latestAtr > atrAvg * 2.5 || latestAtr < atrAvg * 0.25) return [];

      const isUptrend = latestEma50 > latestEma200;
      const isDowntrend = latestEma50 < latestEma200;
      const pipSize = getPipSize(pair);
      const trades = [];

      if (isUptrend && higherTrend === 'up' && latestRsi > 48 && latestRsi < 75) {
        const sl = latestClose - latestAtr * 1.1;
        const tp = latestClose + latestAtr * 1.6;
        const slPips = Math.abs(latestClose - sl) / pipSize;
        const tpPips = Math.abs(tp - latestClose) / pipSize;
        const rr = tpPips / slPips;
        if (rr >= 1.15) {
          const trade = buildTrade(pair, 'buy', latestClose, sl, tp, slPips, tpPips, rr, 0);
          if (trade.winProb > 60) trades.push({ ...trade, relaxed: true });
        }
      }

      if (isDowntrend && higherTrend === 'down' && latestRsi < 52 && latestRsi > 25) {
        const sl = latestClose + latestAtr * 1.1;
        const tp = latestClose - latestAtr * 1.6;
        const slPips = Math.abs(sl - latestClose) / pipSize;
        const tpPips = Math.abs(latestClose - tp) / pipSize;
        const rr = tpPips / slPips;
        if (rr >= 1.15) {
          const trade = buildTrade(pair, 'sell', latestClose, sl, tp, slPips, tpPips, rr, 0);
          if (trade.winProb > 60) trades.push({ ...trade, relaxed: true });
        }
      }

      return trades;
    }

    // === MAIN SIGNAL GENERATOR ===
    async function generateDailySignals() {
      const session = getCurrentSession();
      document.getElementById('sessionLabel').textContent = session;
      document.getElementById('status').textContent = `🔍 Analyzing ${PAIRS.length} pairs (1H + 4H) • Session: ${session}`;

      let strictTrades = [];
      let relaxedTrades = [];

      for (const pair of PAIRS) {
        const trades = await analyzePairStrict(pair);
        strictTrades = strictTrades.concat(trades);
        await new Promise(r => setTimeout(r, 100));
      }

      for (const pair of PAIRS) {
        const trades = await analyzePairRelaxed(pair);
        relaxedTrades = relaxedTrades.concat(trades);
        await new Promise(r => setTimeout(r, 100));
      }

      let allTrades = [...strictTrades];
      const needed = Math.max(0, 3 - strictTrades.length);
      if (needed > 0) {
        relaxedTrades.sort((a, b) => b.winProb - a.winProb);
        allTrades = allTrades.concat(relaxedTrades.slice(0, needed));
      }

      allTrades.sort((a, b) => b.winProb - a.winProb);
      allTrades = allTrades.slice(0, 3);

      const container = document.getElementById('tradesContainer');
      if (allTrades.length === 0) {
        container.innerHTML = '<div class="error">🚫 No valid setups found. Market conditions extremely unfavorable.</div>';
        document.getElementById('status').textContent = '✅ Analysis complete – no signals';
        return;
      }

      let html = `<p>🎯 <b>${allTrades.length} Trade Opportunities</b> (R1000 • 1% Risk)</p>`;
      allTrades.forEach((t, i) => {
        const dir = t.direction === 'buy' ? '🟢 BUY' : '🔴 SELL';
        const decimals = t.pair.includes('JPY') ? 3 : t.pair.includes('XAU') ? 2 : 5;
        const confColor = t.confidence === "High" ? "#27ae60" : t.confidence === "Medium" ? "#f1c40f" : "#e67e22";
        html += `
          <div class="trade-card" style="border-left-color:${confColor}">
            <b>#${i+1} • ${t.pair} • ${dir}</b>
            <span style="background:${confColor};color:white;padding:2px 6px;border-radius:4px;font-size:0.8em;margin-left:6px;">
              ${t.confidence} Confidence
            </span>
            ${t.relaxed ? '<span style="background:#9b59b6;color:white;padding:2px 6px;border-radius:4px;font-size:0.8em;margin-left:6px;">Relaxed</span>' : ''}
            <div>Entry: ${t.entry.toFixed(decimals)} | SL: ${t.sl.toFixed(decimals)} (${t.slPips.toFixed(1)}p) | TP: ${t.tp.toFixed(decimals)} (${t.tpPips.toFixed(1)}p)</div>
            <div>R:R = 1:${t.rr.toFixed(2)} | Win Prob: ${t.winProb}% | Size: ${t.microLots.toFixed(1)} micro lots</div>
          </div>
        `;
      });
      container.innerHTML = html;
      document.getElementById('status').textContent = `✅ ${allTrades.length} opportunity${allTrades.length !== 1 ? 's' : ''} ready`;

      setTimeout(() => {
        document.getElementById('status').textContent = '🔄 Auto-refreshing...';
        generateDailySignals();
      }, 30 * 60 * 1000);
    }

    // ==============================
    // === BACKTESTING SECTION ===
    // ==============================

    async function fetchHistoricalCandles(pair, interval, days = 90) {
      const symbol = pair.replace('/', '');
      const chunks = [];
      let endDate = new Date();
      const candlesPerChunk = 200;
      const daysPerChunk = interval === '1h' ? 8 : 32;
      const chunksNeeded = Math.ceil(days / daysPerChunk);

      for (let i = 0; i < chunksNeeded; i++) {
        const dateStr = endDate.toISOString().split('T')[0];
        const url = `https://api.twelvedata.com/time_series?symbol=${symbol}&interval=${interval}&outputsize=${candlesPerChunk}&end_date=${dateStr}&apikey=${API_KEY}`;
        try {
          const res = await fetch(url);
          const data = await res.json();
          if (data.values && data.values.length > 0) {
            const chunk = {
              close: data.values.map(v => parseFloat(v.close)),
              high: data.values.map(v => parseFloat(v.high)),
              low: data.values.map(v => parseFloat(v.low)),
              timestamp: data.values.map(v => new Date(v.datetime))
            };
            chunks.push(chunk);
            const lastTime = new Date(data.values[data.values.length - 1].datetime);
            endDate = new Date(lastTime.getTime() - 60000);
          } else break;
        } catch (e) {
          console.error(`Backtest fetch error for ${pair} ${interval}:`, e);
          break;
        }
        await new Promise(r => setTimeout(r, 200));
      }

      let merged = { close: [], high: [], low: [], timestamp: [] };
      for (let i = chunks.length - 1; i >= 0; i--) {
        merged.close.push(...chunks[i].close);
        merged.high.push(...chunks[i].high);
        merged.low.push(...chunks[i].low);
        merged.timestamp.push(...chunks[i].timestamp);
      }
      return merged;
    }

    async function runBacktest() {
      const btn = document.getElementById('backtestBtn');
      const resultsDiv = document.getElementById('backtestResults');
      btn.disabled = true;
      btn.textContent = '⏳ Running backtest... (30-60 sec)';
      resultsDiv.style.display = 'none';

      const testPairs = ['EUR/USD', 'GBP/USD', 'XAU/USD'];
      let allTrades = [];
      let equity = 1000;
      let maxEquity = 1000;
      let maxDrawdown = 0;

      for (const pair of testPairs) {
        const hist1h = await fetchHistoricalCandles(pair, '1h', 90);
        const hist4h = await fetchHistoricalCandles(pair, '4h', 90);
        if (!hist1h.close.length || !hist4h.close.length) continue;

        // Build 4H index map for faster lookup
        const time4h = hist4h.timestamp;
        for (let i = 50; i < hist1h.close.length - 50; i++) {
          const time1h = hist1h.timestamp[i];
          let j = 0;
          while (j < time4h.length - 1 && time4h[j] <= time1h) j++;
          j = Math.min(j, hist4h.close.length - 1);

          // Slice data up to current point
          const c1 = hist1h.close.slice(0, i+1);
          const h1 = hist1h.high.slice(0, i+1);
          const l1 = hist1h.low.slice(0, i+1);
          const c4 = hist4h.close.slice(0, j+1);
          const h4 = hist4h.high.slice(0, j+1);
          const l4 = hist4h.low.slice(0, j+1);

          const trade = analyzeHistoricalPoint(pair, c1, h1, l1, c4, h4, l4);
          if (trade) {
            // Simulate outcome over next 48 hours (48 candles)
            const futureHigh = hist1h.high.slice(i+1, i+49);
            const futureLow = hist1h.low.slice(i+1, i+49);
            let outcome = null;
            let exitPrice = null;

            if (trade.direction === 'buy') {
              if (futureLow.some(low => low <= trade.sl)) {
                outcome = 'loss';
                exitPrice = trade.sl;
              } else if (futureHigh.some(high => high >= trade.tp)) {
                outcome = 'win';
                exitPrice = trade.tp;
              }
            } else {
              if (futureHigh.some(high => high >= trade.sl)) {
                outcome = 'loss';
                exitPrice = trade.sl;
              } else if (futureLow.some(low => low <= trade.tp)) {
                outcome = 'win';
                exitPrice = trade.tp;
              }
            }

            if (outcome) {
              const pipSize = getPipSize(pair);
              const pips = trade.direction === 'buy' 
                ? (exitPrice - trade.entry) / pipSize 
                : (trade.entry - exitPrice) / pipSize;
              const riskAmount = 10; // 1% of 1000
              const pnl = (riskAmount / trade.slPips) * pips;

              allTrades.push({ ...trade, outcome, pips, pnl, date: time1h });

              equity += pnl;
              maxEquity = Math.max(maxEquity, equity);
              const dd = (maxEquity - equity) / maxEquity;
              maxDrawdown = Math.max(maxDrawdown, dd);
            }
          }
        }
      }

      // Stats
      const wins = allTrades.filter(t => t.outcome === 'win').length;
      const winRate = allTrades.length ? (wins / allTrades.length
